
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <title>Duality tracker</title>
    <style>
      :root {
        --bg: #a87444;
        --black: #111111;
        --white: #f6f1e6;
        --text-subtle: rgba(73, 45, 23, 0.72);
        --text-subtle-soft: rgba(73, 45, 23, 0.6);
        --condensed:
          "Futura-CondensedExtraBold", "Futura Condensed", "Avenir Next Condensed",
          "Arial Narrow", "Roboto Condensed", "Impact", sans-serif;
      }

      html,
      body {
        height: 100%;
      }

      body {
        margin: 0;
        background: var(--bg);
        min-height: 100svh;
        min-height: 100dvh;
        overscroll-behavior: none;
        -webkit-text-size-adjust: 100%;
        display: grid;
        place-items: center;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      }

      .app {
        width: min(96vw, 980px);
        min-height: 100svh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: clamp(12px, 2.2vh, 24px);
        padding: calc(10px + env(safe-area-inset-top)) 0 calc(14px + env(safe-area-inset-bottom));
        box-sizing: border-box;
      }

      .instruction {
        margin: 0;
        max-width: 68ch;
        text-align: center;
        font-size: clamp(10px, 1.02vw, 11px);
        line-height: 1.3;
        letter-spacing: 0.01em;
        color: rgba(73, 45, 23, 0.44);
      }

      .symbol-stage {
        width: min(88vw, 74svh, 760px);
        position: relative;
      }

      .wrap {
        width: 100%;
        aspect-ratio: 1;
        display: grid;
        place-items: center;
      }

      .date-stamp {
        position: absolute;
        z-index: 2;
        font-family: var(--condensed);
        font-size: clamp(14px, 2.8vmin, 30px);
        font-weight: 700;
        line-height: 1;
        letter-spacing: 0.028em;
        text-transform: uppercase;
        user-select: none;
        pointer-events: none;
      }

      .date-top {
        top: -3.6%;
        right: -2.8%;
        color: rgba(246, 241, 230, 0.96);
      }

      .date-bottom {
        bottom: -3.6%;
        left: -2.8%;
        transform: rotate(180deg);
        transform-origin: center;
        color: rgba(17, 17, 17, 0.94);
      }

      .meta {
        width: min(94vw, 760px);
        display: grid;
        justify-items: center;
        gap: 5px;
      }

      .instruction-row {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        font-size: clamp(10px, 1.02vw, 11px);
        margin-top: 4px;
      }

      .instruction-row .instruction {
        max-width: 68ch;
        white-space: normal;
      }

      .button-row {
        display: grid;
        place-items: center;
        width: 100%;
      }

      .shot-btn {
        border: 1px solid rgba(73, 45, 23, 0.34);
        background: transparent;
        color: rgba(73, 45, 23, 0.44);
        border-radius: 999px;
        padding: 3px 10px;
        font-family: inherit;
        font-size: clamp(10px, 1.02vw, 11px);
        font-weight: 400;
        letter-spacing: 0.01em;
        line-height: 1.2;
        cursor: pointer;
        appearance: none;
        -webkit-appearance: none;
        transition: background-color 120ms ease, color 120ms ease, border-color 120ms ease;
      }

      .shot-btn:hover {
        background: rgba(73, 45, 23, 0.08);
      }

      .shot-btn:active {
        background: rgba(73, 45, 23, 0.12);
      }

      .shot-btn.is-saving {
        opacity: 0.75;
      }

      .shot-btn:focus-visible {
        outline: 2px solid rgba(17, 17, 17, 0.4);
        outline-offset: 2px;
      }

      .save-status {
        min-height: 1em;
        margin: 0;
        font-size: clamp(9px, 0.92vw, 10px);
        color: rgba(73, 45, 23, 0.38);
      }

      canvas {
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
        -webkit-tap-highlight-color: transparent;
      }

      @media (max-width: 760px) {
        .app {
          gap: 10px;
          padding-top: calc(8px + env(safe-area-inset-top));
          padding-bottom: calc(10px + env(safe-area-inset-bottom));
        }

        .symbol-stage {
          width: min(94vw, 70svh, 620px);
        }

        .date-stamp {
          font-size: clamp(12px, 2.2vmin, 20px);
        }

        .date-top {
          top: -3%;
          right: -2.1%;
        }

        .date-bottom {
          bottom: -3%;
          left: -2.1%;
        }

        .meta {
          width: min(94vw, 620px);
          gap: 4px;
        }

        .instruction {
          font-size: clamp(10px, 2.8vw, 11px);
        }

        .instruction-row .instruction {
          max-width: 56ch;
        }
      }
    </style>
  </head>
  <body>
    <main class="app">
      <section class="symbol-stage" aria-label="Duality symbol with date">
        <div class="date-stamp date-top" id="dateTop"></div>
        <section class="wrap">
          <canvas id="yy" aria-label="Interactive yin yang mood tracker"></canvas>
        </section>
        <div class="date-stamp date-bottom" id="dateBottom"></div>
      </section>
      <section class="meta">
        <p class="instruction">
          Click and drag on each unique element of the symbol
        </p>
        <p class="instruction">make it reflect the balance of light and dark within you today</p>
        <div class="instruction-row">
          <p class="instruction">take a screenshot to track your daily moods and perceptions of self</p>
        </div>
        <div class="button-row">
          <button class="shot-btn" id="saveShot" type="button">screenshot</button>
        </div>
        <p class="save-status" id="saveStatus" aria-live="polite"></p>
      </section>
    </main>

    <script>
      (() => {
        const TAU = Math.PI * 2;
        const canvas = document.getElementById("yy");
        const dateTop = document.getElementById("dateTop");
        const dateBottom = document.getElementById("dateBottom");
        const saveShotButton = document.getElementById("saveShot");
        const saveStatus = document.getElementById("saveStatus");
        const ctx = canvas.getContext("2d", { alpha: true });
        const rootStyles = getComputedStyle(document.documentElement);
        const CONDENSED_FONT_STACK =
          '"Futura-CondensedExtraBold","Futura Condensed","Avenir Next Condensed","Arial Narrow","Roboto Condensed","Impact",sans-serif';
        const isIOSLike =
          /iPad|iPhone|iPod/.test(navigator.userAgent) ||
          (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
        const saveState = {
          isSaving: false,
          statusTimeout: 0,
        };

        function formatDisplayDate(date = new Date()) {
          const parts = new Intl.DateTimeFormat("en-US", {
            month: "short",
            day: "numeric",
            year: "numeric",
          }).formatToParts(date);
          const month = (parts.find((part) => part.type === "month")?.value || "").toUpperCase();
          const day = parts.find((part) => part.type === "day")?.value || "";
          const year = parts.find((part) => part.type === "year")?.value || "";
          return `${month} ${day} ${year}`.trim();
        }

        function renderDateStamps() {
          const stamp = formatDisplayDate(new Date());
          dateTop.textContent = stamp;
          dateBottom.textContent = stamp;
        }
        renderDateStamps();
        window.setInterval(renderDateStamps, 60_000);

        function formatFilenameStamp(date = new Date()) {
          const year = String(date.getFullYear());
          const month = String(date.getMonth() + 1).padStart(2, "0");
          const day = String(date.getDate()).padStart(2, "0");
          const hour = String(date.getHours()).padStart(2, "0");
          const minute = String(date.getMinutes()).padStart(2, "0");
          const second = String(date.getSeconds()).padStart(2, "0");
          return {
            date: `${year}-${month}-${day}`,
            time: `${hour}-${minute}-${second}`,
          };
        }

        function setSaveStatus(message) {
          saveStatus.textContent = message;
          if (saveState.statusTimeout) {
            clearTimeout(saveState.statusTimeout);
            saveState.statusTimeout = 0;
          }
          if (!message) return;
          saveState.statusTimeout = window.setTimeout(() => {
            saveStatus.textContent = "";
            saveState.statusTimeout = 0;
          }, 2600);
        }

        const COLORS = {
          black: getComputedStyle(document.documentElement).getPropertyValue("--black").trim(),
          white: getComputedStyle(document.documentElement).getPropertyValue("--white").trim(),
        };
        const DOT_PADDING_CSS = 5;
        const DOT_RESIZE_INNER_PAD_CSS = 4;

        const state = {
          whitePush: 0.5,
          blackPush: 0.5,
          whiteLift: 0,
          blackLift: 0,
          whiteLocalShiftX: 0,
          blackLocalShiftX: 0,
          whiteFocusY: -0.5,
          blackFocusY: 0.5,
          topDotScale: 1,
          bottomDotScale: 1,
        };

        const SELECTION_RING_WIDTH_CSS = 6;

        const drag = {
          active: false,
          pointerId: null,
          mode: null, // "white" | "black" | "topDotResize" | "bottomDotResize"
          start: { x: 0, y: 0 },
          last: { x: 0, y: 0 },
          startWhitePush: 0.5,
          startBlackPush: 0.5,
          startWhiteLift: 0,
          startBlackLift: 0,
          startWhiteLocalShiftX: 0,
          startBlackLocalShiftX: 0,
          startWhiteFocusY: -0.5,
          startBlackFocusY: 0.5,
          startTopScale: 1,
          startBottomScale: 1,
          grabYNorm: 0,
          topInfluence: 0.5,
          bottomInfluence: 0.5,
          activeDotCenter: { x: 0, y: 0 },
          activeDotStartDist: 0,
        };

        const dotMemory = {
          top: null,
          bottom: null,
        };

        function clamp(n, min, max) {
          return Math.min(max, Math.max(min, n));
        }

        function getGrabInfluence(yNorm) {
          const yn = clamp(yNorm, -1, 1);
          const sigma = 0.46;
          const topRaw = Math.exp(-Math.pow((yn + 0.52) / sigma, 2));
          const bottomRaw = Math.exp(-Math.pow((yn - 0.52) / sigma, 2));
          const sum = topRaw + bottomRaw + 1e-9;
          return { top: topRaw / sum, bottom: bottomRaw / sum };
        }

        function resizeCanvasToDisplaySize() {
          const rect = canvas.getBoundingClientRect();
          const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
          const w = Math.max(2, Math.round(rect.width * dpr));
          const h = Math.max(2, Math.round(rect.height * dpr));
          if (canvas.width !== w || canvas.height !== h) {
            canvas.width = w;
            canvas.height = h;
          }
        }

        function getLocalPoint(e) {
          const rect = canvas.getBoundingClientRect();
          const sx = canvas.width / rect.width;
          const sy = canvas.height / rect.height;
          const x = (e.clientX - rect.left) * sx;
          const y = (e.clientY - rect.top) * sy;
          return { x: x - canvas.width / 2, y: y - canvas.height / 2 };
        }

        function getRadius() {
          return Math.min(canvas.width, canvas.height) * 0.44;
        }

        function getCanvasScale() {
          return canvas.width / Math.max(1, canvas.clientWidth || 1);
        }

        function isInsideCircle(x, y, R) {
          return x * x + y * y <= R * R;
        }

        function getLobeCoefficients() {
          const whiteDelta = (state.whitePush - 0.5) * 2;
          const blackDelta = (state.blackPush - 0.5) * 2;
          const topDrive = 1.36 * whiteDelta - 0.66 * blackDelta;
          const bottomDrive = 1.36 * blackDelta - 0.66 * whiteDelta;
          const topCoeff = clamp(0.5 * Math.exp(topDrive), 0.12, 1.45);
          const bottomCoeff = clamp(0.5 * Math.exp(bottomDrive), 0.12, 1.45);
          return { whiteDelta, blackDelta, topCoeff, bottomCoeff };
        }

        function getLobeCenters(R) {
          const half = R * 0.5;
          let topCenter = -half + state.whiteLift * 0.94 * R;
          let bottomCenter = half + state.blackLift * 0.94 * R;

          topCenter = clamp(topCenter, -1.14 * R, 0.92 * R);
          bottomCenter = clamp(bottomCenter, -0.92 * R, 1.14 * R);

          const minGap = 0.03 * R;
          const maxGap = 1.98 * R;
          let gap = bottomCenter - topCenter;
          if (gap < minGap) {
            const spread = (minGap - gap) * 0.5;
            topCenter -= spread;
            bottomCenter += spread;
          } else if (gap > maxGap) {
            const compress = (gap - maxGap) * 0.5;
            topCenter += compress;
            bottomCenter -= compress;
          }
          gap = bottomCenter - topCenter;
          if (gap < minGap) {
            const mid = (topCenter + bottomCenter) * 0.5;
            topCenter = mid - minGap * 0.5;
            bottomCenter = mid + minGap * 0.5;
          }

          return { topCenter, bottomCenter };
        }

        function baseDividerX(y, R) {
          const half = R * 0.5;
          if (y <= 0) {
            const dy = y + half;
            return Math.sqrt(Math.max(0, half * half - dy * dy));
          }
          const dy = y - half;
          return -Math.sqrt(Math.max(0, half * half - dy * dy));
        }

        function dividerXAtY(y, R) {
          const t = y / R;
          const { whiteDelta, blackDelta, topCoeff, bottomCoeff } = getLobeCoefficients();
          const { topCenter, bottomCenter } = getLobeCenters(R);
          const dominance = clamp(state.whitePush - state.blackPush, -1, 1);
          const dominanceAbs = Math.abs(dominance);
          const outerX = Math.sqrt(Math.max(0, R * R - y * y));

          const base = baseDividerX(y, R);
          const sigma = 0.37 * R;
          const topProfile = Math.exp(-Math.pow((y - topCenter) / sigma, 2));
          const bottomProfile = Math.exp(-Math.pow((y - bottomCenter) / sigma, 2));
          const middleProfile = Math.exp(-Math.pow(y / (0.52 * R), 2));
          const envelope = Math.pow(Math.max(0, 1 - t * t), 1.25);
          const edgeEnvelope = 0.3 + 0.7 * envelope;
          const dominanceBoost = 1 + 2.2 * Math.pow(dominanceAbs, 2.1);

          const topDrive = topCoeff - 0.5;
          const bottomDrive = bottomCoeff - 0.5;
          let deform =
            0.78 * topDrive * topProfile -
            0.78 * bottomDrive * bottomProfile +
            0.2 * (topDrive - bottomDrive) * middleProfile +
            0.52 * state.whiteLift * topProfile -
            0.52 * state.blackLift * bottomProfile +
            0.34 * (state.whiteLift - state.blackLift) * t;
          deform *= envelope * R;

          const localSigma = 0.28 * R;
          const whiteLocalCenter = clamp(
            (state.whiteFocusY + state.whiteLift * 0.08) * R,
            -0.95 * R,
            0.95 * R
          );
          const blackLocalCenter = clamp(
            (state.blackFocusY + state.blackLift * 0.08) * R,
            -0.95 * R,
            0.95 * R
          );
          const whiteLocalProfile = Math.exp(-Math.pow((y - whiteLocalCenter) / localSigma, 2));
          const blackLocalProfile = Math.exp(-Math.pow((y - blackLocalCenter) / localSigma, 2));
          const localDeform =
            (0.62 * state.whiteLocalShiftX * whiteLocalProfile -
              0.62 * state.blackLocalShiftX * blackLocalProfile) *
            edgeEnvelope *
            envelope *
            R;

          let x = base + deform + localDeform;
          const dominanceShift =
            dominance * outerX * (0.66 + 0.1 * middleProfile) * edgeEnvelope * dominanceBoost;
          x += dominanceShift;

          const limit = outerX * 0.9992;
          if (limit <= 1e-9) return 0;
          x = limit * Math.tanh(x / (limit + 1e-9));
          return x;
        }

        function getDotScaleBias(areaFractions) {
          const { topCoeff, bottomCoeff } = getLobeCoefficients();
          const whiteFrac = clamp(areaFractions?.white ?? 0.5, 0.01, 0.99);
          const blackFrac = clamp(areaFractions?.black ?? 0.5, 0.01, 0.99);

          const areaToBias = (fraction) => clamp(Math.pow(fraction / 0.5, 1.6), 0.03, 1.26);
          const shapeToBias = (coeff) => clamp(Math.pow(coeff / 0.5, 0.28), 0.82, 1.16);

          const topAreaBias = areaToBias(whiteFrac);
          const bottomAreaBias = areaToBias(blackFrac);
          const topShapeBias = shapeToBias(topCoeff);
          const bottomShapeBias = shapeToBias(bottomCoeff);

          return {
            top: clamp(topAreaBias * 0.9 + topShapeBias * 0.1, 0.03, 1.26),
            bottom: clamp(bottomAreaBias * 0.9 + bottomShapeBias * 0.1, 0.03, 1.26),
          };
        }

        function getGlobalDeformAmount() {
          const pushDelta =
            Math.max(Math.abs(state.whitePush - 0.5), Math.abs(state.blackPush - 0.5)) * 2;
          const liftDelta = Math.max(Math.abs(state.whiteLift), Math.abs(state.blackLift));
          return clamp(Math.max(pushDelta, liftDelta), 0, 1);
        }

        function smoothDividerPoints(points, passes = 2) {
          if (points.length < 5 || passes <= 0) return points;
          let xs = points.map((point) => point.x);
          const n = xs.length;

          for (let pass = 0; pass < passes; pass += 1) {
            const next = xs.slice();
            for (let i = 2; i < n - 2; i += 1) {
              next[i] =
                (xs[i - 2] + 4 * xs[i - 1] + 6 * xs[i] + 4 * xs[i + 1] + xs[i + 2]) / 16;
            }
            next[1] = (xs[0] + 2 * xs[1] + xs[2]) * 0.25;
            next[n - 2] = (xs[n - 3] + 2 * xs[n - 2] + xs[n - 1]) * 0.25;
            xs = next;
          }

          return points.map((point, index) => ({ x: xs[index], y: point.y }));
        }

        function buildDivider(R, globalDeform, steps = 900) {
          const points = [];
          for (let i = 0; i <= steps; i += 1) {
            const y = -R + (2 * R * i) / steps;
            points.push({ x: dividerXAtY(y, R), y });
          }
          const smoothPasses = globalDeform < 0.05 ? 0 : 2;
          return smoothDividerPoints(points, smoothPasses);
        }

        function estimateColorFractions(R, dividerPoints) {
          const steps = Math.max(1, dividerPoints.length - 1);
          const dy = (2 * R) / steps;
          let whiteArea = 0;

          for (let i = 0; i < dividerPoints.length; i += 1) {
            const y = dividerPoints[i].y;
            const outerX = Math.sqrt(Math.max(0, R * R - y * y));
            const dividerX = clamp(dividerPoints[i].x, -outerX, outerX);
            const whiteSpan = clamp(dividerX + outerX, 0, 2 * outerX);
            whiteArea += whiteSpan * dy;
          }

          const totalArea = Math.PI * R * R;
          const white = clamp(whiteArea / Math.max(1e-6, totalArea), 0, 1);
          return { white, black: 1 - white };
        }

        function isWhiteAt(x, y, R) {
          return x <= dividerXAtY(y, R);
        }

        function findDotAuto(R, region, scaleFactor, padding, lobeCenters, stackAxisX) {
          const isTop = region === "top";
          const dominance = clamp(state.whitePush - state.blackPush, -1, 1);
          const lift = isTop ? state.whiteLift : state.blackLift;
          const focusRaw = isTop ? state.whiteFocusY : state.blackFocusY;
          const focusClamped = isTop ? clamp(focusRaw, -0.95, 0.2) : clamp(focusRaw, -0.2, 0.95);
          const baseAnchorY = isTop ? -0.44 * R : 0.44 * R;
          const lobeCenterY = isTop ? lobeCenters.topCenter : lobeCenters.bottomCenter;
          const preferredY = clamp(
            baseAnchorY +
              lift * 0.38 * R +
              focusClamped * 0.08 * R +
              (lobeCenterY - baseAnchorY) * 0.24,
            isTop ? -0.95 * R : -0.22 * R,
            isTop ? 0.22 * R : 0.95 * R
          );

          const getHostRangeAtY = (y) => {
            const outer = Math.sqrt(Math.max(0, R * R - y * y));
            const divider = clamp(dividerXAtY(y, R), -outer, outer);
            const left = isTop ? -outer : divider;
            const right = isTop ? divider : outer;
            return { left, right, span: Math.max(0, right - left) };
          };

          const yAnchor = preferredY;
          const hostAtAnchor = getHostRangeAtY(preferredY);
          const xAnchor =
            stackAxisX * 0.86 +
            (hostAtAnchor.left + hostAtAnchor.right) * 0.14 +
            dominance * (isTop ? 0.015 : -0.015) * R;
          const spanX = 0.88 * R;
          const spanY = 0.92 * R;
          const cols = 56;
          const rows = 56;
          const yMin = Math.max(isTop ? -R : -0.24 * R, yAnchor - spanY * 0.5);
          const yMax = Math.min(isTop ? 0.24 * R : R, yAnchor + spanY * 0.5);

          let best = null;
          const pool = [];

          for (let iy = 0; iy <= rows; iy += 1) {
            const y = yMin + ((yMax - yMin) * iy) / rows;
            const outer = Math.sqrt(Math.max(0, R * R - y * y));
            for (let ix = 0; ix <= cols; ix += 1) {
              const x = xAnchor - spanX * 0.5 + (spanX * ix) / cols;
              if (Math.abs(x) >= outer) continue;

              const white = isWhiteAt(x, y, R);
              if ((isTop && !white) || (!isTop && white)) continue;

              const dOuter = R - Math.hypot(x, y);
              const dDivider = Math.abs(x - dividerXAtY(y, R));
              const maxR = Math.min(dOuter, dDivider) - padding;
              if (maxR <= 0) continue;

              const roomN = maxR / R;
              const depthN = dDivider / R;
              const verticalN = 1 - clamp(Math.abs(y - yAnchor) / (0.52 * R), 0, 1);
              const anchorN = 1 - clamp(Math.hypot((x - xAnchor) / (0.64 * R), (y - yAnchor) / (0.52 * R)), 0, 1);
              const stackN = 1 - clamp(Math.abs(x - stackAxisX) / (0.34 * R), 0, 1);
              const score =
                1.92 * roomN + 0.2 * depthN + 0.2 * verticalN + 0.15 * anchorN + 1.05 * stackN;
              const candidate = { x, y, maxR, score };
              pool.push(candidate);

              if (!best || score > best.score) {
                best = candidate;
              }
            }
          }

          if (!best) {
            return { x: xAnchor, y: yAnchor, r: R * 0.08, room: R * 0.08 };
          }

          let chosen = best;
          if (pool.length > 1) {
            const cutoff = best.score - 0.07;
            let wSum = 0;
            let xSum = 0;
            let ySum = 0;
            let roomSum = 0;
            for (let i = 0; i < pool.length; i += 1) {
              const candidate = pool[i];
              if (candidate.score < cutoff) continue;
              const weight = Math.exp((candidate.score - best.score) * 11);
              wSum += weight;
              xSum += candidate.x * weight;
              ySum += candidate.y * weight;
              roomSum += candidate.maxR * weight;
            }
            if (wSum > 1e-6) {
              chosen = {
                x: xSum / wSum,
                y: ySum / wSum,
                maxR: roomSum / wSum,
                score: best.score,
              };
            }
          }

          const maxAllowed = Math.min(chosen.maxR * 0.6, R * 0.21);
          const minAllowed = Math.min(R * 0.008, maxAllowed);
          return {
            x: chosen.x,
            y: chosen.y,
            r: clamp(chosen.maxR * scaleFactor, minAllowed, maxAllowed),
            room: chosen.maxR,
          };
        }

        function getDotRoomAt(x, y, R, isTop, padding) {
          if (!isInsideCircle(x, y, R)) return 0;
          const white = isWhiteAt(x, y, R);
          if ((isTop && !white) || (!isTop && white)) return 0;
          const dOuter = R - Math.hypot(x, y);
          const dDivider = Math.abs(x - dividerXAtY(y, R));
          return Math.max(0, Math.min(dOuter, dDivider) - padding);
        }

        function constrainDotToBlob(targetX, targetY, R, r, isTop, padding) {
          const safePadding = padding * 1.25;
          const safeOuterR = Math.max(0, R - (r + safePadding));
          const steps = 180;
          let best = null;

          for (let i = 0; i <= steps; i += 1) {
            const y = -safeOuterR + (2 * safeOuterR * i) / steps;
            const outerX = Math.sqrt(Math.max(0, safeOuterR * safeOuterR - y * y));
            const dividerX = dividerXAtY(y, R);
            const wall = r + safePadding;
            let left = -outerX;
            let right = outerX;

            if (isTop) {
              right = Math.min(right, dividerX - wall);
            } else {
              left = Math.max(left, dividerX + wall);
            }
            if (right < left) continue;

            const x = clamp(targetX, left, right);
            const distSq = (x - targetX) * (x - targetX) + (y - targetY) * (y - targetY);
            if (!best || distSq < best.distSq) {
              best = { x, y, distSq };
            }
          }

          if (!best) {
            return null;
          }
          return { x: best.x, y: best.y };
        }

        function constrainDotXAtY(targetX, y, R, r, isTop, padding) {
          const safePadding = padding * 1.25;
          const safeOuterR = Math.max(0, R - (r + safePadding));
          if (Math.abs(y) > safeOuterR) return null;
          const outerX = Math.sqrt(Math.max(0, safeOuterR * safeOuterR - y * y));
          const dividerX = dividerXAtY(y, R);
          const wall = r + safePadding;
          let left = -outerX;
          let right = outerX;
          if (isTop) {
            right = Math.min(right, dividerX - wall);
          } else {
            left = Math.max(left, dividerX + wall);
          }
          if (right < left) return null;
          return clamp(targetX, left, right);
        }

        function fitDotInsideBlob(dot, R, isTop, padding) {
          let radius = Math.max(0.35, dot.r);
          let point = constrainDotToBlob(dot.x, dot.y, R, radius, isTop, padding);

          for (let i = 0; i < 8 && !point; i += 1) {
            radius *= 0.84;
            point = constrainDotToBlob(dot.x, dot.y, R, radius, isTop, padding);
          }

          if (!point) {
            const fallbackY = isTop ? -0.5 * R : 0.5 * R;
            const fallbackX = baseDividerX(0, R);
            radius = Math.max(0.35, Math.min(radius, R * 0.035));
            point = constrainDotToBlob(fallbackX, fallbackY, R, radius, isTop, padding);
          }

          if (!point) {
            point = { x: dot.x, y: dot.y };
          }

          return { x: point.x, y: point.y, r: radius };
        }

        function stabilizeDotCenter(targetDot, key, R, isTop, padding) {
          const memory = dotMemory[key];
          const fittedTarget = fitDotInsideBlob(targetDot, R, isTop, padding);

          if (!memory) {
            dotMemory[key] = { x: fittedTarget.x, y: fittedTarget.y };
            return fittedTarget;
          }

          const isResizing =
            (key === "top" && drag.active && drag.mode === "topDotResize") ||
            (key === "bottom" && drag.active && drag.mode === "bottomDotResize");
          const distN =
            Math.hypot(fittedTarget.x - memory.x, fittedTarget.y - memory.y) / Math.max(1e-6, R);
          const follow = isResizing ? clamp(0.72 + distN * 0.2, 0.72, 0.9) : clamp(0.24 + distN * 0.5, 0.24, 0.62);

          memory.x += (fittedTarget.x - memory.x) * follow;
          memory.y += (fittedTarget.y - memory.y) * follow;

          const fittedMemory = fitDotInsideBlob({ x: memory.x, y: memory.y, r: fittedTarget.r }, R, isTop, padding);
          memory.x = fittedMemory.x;
          memory.y = fittedMemory.y;

          return { x: memory.x, y: memory.y, r: fittedMemory.r };
        }

        function geometry() {
          const R = getRadius();
          const padding = DOT_PADDING_CSS * getCanvasScale();
          const globalDeform = getGlobalDeformAmount();
          const dividerPoints = buildDivider(R, globalDeform);
          const areaFractions = estimateColorFractions(R, dividerPoints);
          const lobeCenters = getLobeCenters(R);
          const stackAxisX = baseDividerX(0, R);
          const topScaleFactor = state.topDotScale;
          const bottomScaleFactor = state.bottomDotScale;
          const topAuto = findDotAuto(R, "top", topScaleFactor, padding, lobeCenters, stackAxisX);
          const bottomAuto = findDotAuto(
            R,
            "bottom",
            bottomScaleFactor,
            padding,
            lobeCenters,
            stackAxisX
          );
          const topPlaced = constrainDotToBlob(topAuto.x, topAuto.y, R, topAuto.r, true, padding);
          const bottomPlaced = constrainDotToBlob(
            bottomAuto.x,
            bottomAuto.y,
            R,
            bottomAuto.r,
            false,
            padding
          );
          let topTarget = topPlaced
            ? { x: topPlaced.x, y: topPlaced.y, r: topAuto.r }
            : { x: topAuto.x, y: topAuto.y, r: topAuto.r };
          let bottomTarget = bottomPlaced
            ? { x: bottomPlaced.x, y: bottomPlaced.y, r: bottomAuto.r }
            : { x: bottomAuto.x, y: bottomAuto.y, r: bottomAuto.r };

          const DOT_BASE_RADIUS_RATIO = 0.12;
          const topBulbPct = clamp((areaFractions.white || 0.5) / 0.5, 0.02, 4.2);
          const bottomBulbPct = clamp((areaFractions.black || 0.5) / 0.5, 0.02, 4.2);

          const stackBias = clamp(0.9 - globalDeform * 0.1, 0.74, 0.9);
          const topStackX = constrainDotXAtY(stackAxisX, topTarget.y, R, topTarget.r, true, padding);
          if (topStackX != null) {
            topTarget.x = topTarget.x * (1 - stackBias) + topStackX * stackBias;
          }
          const bottomStackX = constrainDotXAtY(
            stackAxisX,
            bottomTarget.y,
            R,
            bottomTarget.r,
            false,
            padding
          );
          if (bottomStackX != null) {
            bottomTarget.x = bottomTarget.x * (1 - stackBias) + bottomStackX * stackBias;
          }

          const pairedStackBias = clamp(0.82 - globalDeform * 0.08, 0.68, 0.82);
          const sharedStackTarget =
            stackAxisX * 0.72 + ((topTarget.x + bottomTarget.x) * 0.5) * 0.28;
          const topSharedX = constrainDotXAtY(
            sharedStackTarget,
            topTarget.y,
            R,
            topTarget.r,
            true,
            padding
          );
          if (topSharedX != null) {
            topTarget.x = topTarget.x * (1 - pairedStackBias) + topSharedX * pairedStackBias;
          }
          const bottomSharedX = constrainDotXAtY(
            sharedStackTarget,
            bottomTarget.y,
            R,
            bottomTarget.r,
            false,
            padding
          );
          if (bottomSharedX != null) {
            bottomTarget.x = bottomTarget.x * (1 - pairedStackBias) + bottomSharedX * pairedStackBias;
          }

          const topReplaced = constrainDotToBlob(topTarget.x, topTarget.y, R, topTarget.r, true, padding);
          if (topReplaced) {
            topTarget.x = topReplaced.x;
            topTarget.y = topReplaced.y;
          }
          const bottomReplaced = constrainDotToBlob(
            bottomTarget.x,
            bottomTarget.y,
            R,
            bottomTarget.r,
            false,
            padding
          );
          if (bottomReplaced) {
            bottomTarget.x = bottomReplaced.x;
            bottomTarget.y = bottomReplaced.y;
          }

          const topRoom = getDotRoomAt(topTarget.x, topTarget.y, R, true, padding);
          const bottomRoom = getDotRoomAt(bottomTarget.x, bottomTarget.y, R, false, padding);
          const topDesiredR = R * DOT_BASE_RADIUS_RATIO * topBulbPct * topScaleFactor;
          const bottomDesiredR = R * DOT_BASE_RADIUS_RATIO * bottomBulbPct * bottomScaleFactor;
          const topMax = Math.min(topRoom * 0.98, R * 0.46);
          const bottomMax = Math.min(bottomRoom * 0.98, R * 0.46);
          if (topMax > 0) {
            topTarget.r = clamp(topDesiredR, Math.min(R * 0.004, topMax), topMax);
          }
          if (bottomMax > 0) {
            bottomTarget.r = clamp(bottomDesiredR, Math.min(R * 0.004, bottomMax), bottomMax);
          }
          topTarget = fitDotInsideBlob(topTarget, R, true, padding);
          bottomTarget = fitDotInsideBlob(bottomTarget, R, false, padding);

          if (globalDeform < 0.14) {
            const neutralT = clamp(1 - globalDeform / 0.14, 0, 1);
            const neutralAxisX = baseDividerX(0, R);
            const neutralTop = constrainDotToBlob(
              neutralAxisX,
              -0.5 * R,
              R,
              topTarget.r,
              true,
              padding
            );
            const neutralBottom = constrainDotToBlob(
              neutralAxisX,
              0.5 * R,
              R,
              bottomTarget.r,
              false,
              padding
            );
            if (neutralTop) {
              topTarget.x = topTarget.x * (1 - neutralT) + neutralTop.x * neutralT;
              topTarget.y = topTarget.y * (1 - neutralT) + neutralTop.y * neutralT;
            }
            if (neutralBottom) {
              bottomTarget.x = bottomTarget.x * (1 - neutralT) + neutralBottom.x * neutralT;
              bottomTarget.y = bottomTarget.y * (1 - neutralT) + neutralBottom.y * neutralT;
            }
          }

          if (globalDeform < 0.08) {
            const neutralT = clamp(1 - globalDeform / 0.08, 0, 1);
            const axisX = baseDividerX(0, R);
            const topAligned = constrainDotToBlob(axisX, topTarget.y, R, topTarget.r, true, padding);
            const bottomAligned = constrainDotToBlob(
              axisX,
              bottomTarget.y,
              R,
              bottomTarget.r,
              false,
              padding
            );

            if (topAligned) {
              topTarget = {
                x: topTarget.x * (1 - neutralT) + topAligned.x * neutralT,
                y: topTarget.y * (1 - neutralT) + topAligned.y * neutralT,
                r: topTarget.r,
              };
            }
            if (bottomAligned) {
              bottomTarget = {
                x: bottomTarget.x * (1 - neutralT) + bottomAligned.x * neutralT,
                y: bottomTarget.y * (1 - neutralT) + bottomAligned.y * neutralT,
                r: bottomTarget.r,
              };
            }
          }

          const topDot = stabilizeDotCenter(topTarget, "top", R, true, padding);
          const bottomDot = stabilizeDotCenter(bottomTarget, "bottom", R, false, padding);
          return { R, dividerPoints, topDot, bottomDot, padding };
        }

        function drawCircle(cx, cy, r) {
          if (r <= 0) return;
          ctx.beginPath();
          ctx.arc(cx, cy, r, 0, TAU);
          ctx.fill();
        }

        function isInsideHost(x, y, R, isTop) {
          if (!isInsideCircle(x, y, R)) return false;
          const white = isWhiteAt(x, y, R);
          return isTop ? white : !white;
        }

        function rayBoundaryDistance(cx, cy, dirX, dirY, R, isTop) {
          const cDot = cx * dirX + cy * dirY;
          const cSq = cx * cx + cy * cy;
          const disc = cDot * cDot + (R * R - cSq);
          if (disc <= 0) return 0;
          const outerT = -cDot + Math.sqrt(disc);
          let lo = 0;
          let hi = Math.max(1e-4, outerT + 1);

          for (let i = 0; i < 14; i += 1) {
            const mid = (lo + hi) * 0.5;
            const px = cx + dirX * mid;
            const py = cy + dirY * mid;
            if (isInsideHost(px, py, R, isTop)) {
              lo = mid;
            } else {
              hi = mid;
            }
          }
          return lo;
        }

        function getDotBlobPoints(dot, R, isTop, padding) {
          const samples = 44;
          const avails = new Array(samples);
          let minAvail = Infinity;
          let maxAvail = 0;
          const baseRadius = Math.max(0.35, dot.r);

          for (let i = 0; i < samples; i += 1) {
            const angle = (i / samples) * TAU;
            const dirX = Math.cos(angle);
            const dirY = Math.sin(angle);
            const boundaryDist = rayBoundaryDistance(dot.x, dot.y, dirX, dirY, R, isTop);
            const avail = Math.max(0.35, boundaryDist - padding);
            avails[i] = avail;
            minAvail = Math.min(minAvail, avail);
            maxAvail = Math.max(maxAvail, avail);
          }

          const avgAvail = avails.reduce((sum, value) => sum + value, 0) / samples;
          const hostAnisotropy = clamp(
            (maxAvail - minAvail) / Math.max(1e-6, avgAvail),
            0,
            1
          );
          const squeeze = clamp((baseRadius - minAvail) / Math.max(1e-6, baseRadius), 0, 1);
          const globalDeform = getGlobalDeformAmount();
          const deformGate = clamp((globalDeform - 0.02) / 0.2, 0, 1);
          const shapeBlend = clamp(
            (0.075 + 0.54 * hostAnisotropy + 0.31 * squeeze) * deformGate,
            0,
            0.82
          );

          const minRadius = Math.max(
            0.28,
            baseRadius * (1 - (0.48 * squeeze + 0.18 * hostAnisotropy) * deformGate)
          );
          const expandCap = baseRadius * (1 + 0.055 + 0.12 * shapeBlend);

          let radii = avails.map((avail) => {
            const localFactor = clamp(avail / Math.max(1e-6, avgAvail), 0.78, 1.24);
            const profileMatch =
              baseRadius * (1 + (localFactor - 1) * (shapeBlend * 0.64));
            const wallFollow = baseRadius + (avail - baseRadius) * (0.14 * shapeBlend);
            const radius = baseRadius * 0.24 + profileMatch * 0.54 + wallFollow * 0.22;
            return clamp(radius, minRadius, Math.min(avail, expandCap));
          });

          for (let pass = 0; pass < 4; pass += 1) {
            const smoothed = new Array(samples);
            for (let i = 0; i < samples; i += 1) {
              const prev = radii[(i - 1 + samples) % samples];
              const curr = radii[i];
              const next = radii[(i + 1) % samples];
              smoothed[i] = clamp((prev + curr * 2 + next) * 0.25, minRadius, avails[i]);
            }
            radii = smoothed;
          }

          const points = new Array(samples);
          for (let i = 0; i < samples; i += 1) {
            const angle = (i / samples) * TAU;
            const radius = radii[i];
            points[i] = {
              x: dot.x + Math.cos(angle) * radius,
              y: dot.y + Math.sin(angle) * radius,
            };
          }
          let minRadiusFinal = Infinity;
          let maxRadiusFinal = 0;
          for (let i = 0; i < samples; i += 1) {
            minRadiusFinal = Math.min(minRadiusFinal, radii[i]);
            maxRadiusFinal = Math.max(maxRadiusFinal, radii[i]);
          }
          const anisotropy = clamp(
            (maxRadiusFinal - minRadiusFinal) / Math.max(1e-6, baseRadius),
            0,
            1
          );
          return { points, anisotropy, squeeze, deformGate };
        }

        function drawDeformedDot(dot, R, isTop, padding) {
          if (dot.r <= 0) return;
          if (!isInsideHost(dot.x, dot.y, R, isTop)) {
            return;
          }
          const profile = getDotBlobPoints(dot, R, isTop, padding);
          if (
            !profile ||
            profile.points.length < 3 ||
            (profile.deformGate < 0.03 ||
              (profile.squeeze < 0.008 && profile.anisotropy < 0.025) ||
              profile.anisotropy < 0.006 ||
              profile.squeeze > 0.62 ||
              profile.anisotropy > 0.62)
          ) {
            drawCircle(dot.x, dot.y, dot.r);
            return;
          }

          const points = profile.points;
          const n = points.length;
          const startMid = {
            x: (points[n - 1].x + points[0].x) * 0.5,
            y: (points[n - 1].y + points[0].y) * 0.5,
          };

          ctx.beginPath();
          ctx.moveTo(startMid.x, startMid.y);
          for (let i = 0; i < n; i += 1) {
            const curr = points[i];
            const next = points[(i + 1) % n];
            const mid = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };
            ctx.quadraticCurveTo(curr.x, curr.y, mid.x, mid.y);
          }
          ctx.closePath();
          ctx.fill();
        }

        function appendSmoothDivider(points) {
          if (points.length < 2) return;
          ctx.moveTo(points[0].x, points[0].y);
          for (let i = 1; i < points.length - 1; i += 1) {
            const curr = points[i];
            const next = points[i + 1];
            const midX = (curr.x + next.x) * 0.5;
            const midY = (curr.y + next.y) * 0.5;
            ctx.quadraticCurveTo(curr.x, curr.y, midX, midY);
          }
          const last = points[points.length - 1];
          ctx.lineTo(last.x, last.y);
        }

        function traceSmoothDivider(points) {
          if (points.length < 2) return;
          ctx.beginPath();
          appendSmoothDivider(points);
        }

        function appendBlackRegionPath(points, R) {
          appendSmoothDivider(points);
          const arcSteps = 260;
          for (let i = 0; i <= arcSteps; i += 1) {
            const t = i / arcSteps;
            const theta = Math.PI * 0.5 - Math.PI * t;
            ctx.lineTo(R * Math.cos(theta), R * Math.sin(theta));
          }
          ctx.closePath();
        }

        function traceBlackRegionPath(points, R) {
          ctx.beginPath();
          appendBlackRegionPath(points, R);
        }

        function strokeDotOutline(dot, R, isTop, padding) {
          if (!isInsideHost(dot.x, dot.y, R, isTop)) return;
          const profile = getDotBlobPoints(dot, R, isTop, padding);
          if (
            !profile ||
            profile.points.length < 3 ||
            (profile.deformGate < 0.03 ||
              (profile.squeeze < 0.008 && profile.anisotropy < 0.025) ||
              profile.anisotropy < 0.006 ||
              profile.squeeze > 0.62 ||
              profile.anisotropy > 0.62)
          ) {
            ctx.beginPath();
            ctx.arc(dot.x, dot.y, dot.r, 0, TAU);
            ctx.stroke();
            return;
          }

          const points = profile.points;
          const n = points.length;
          const startMid = {
            x: (points[n - 1].x + points[0].x) * 0.5,
            y: (points[n - 1].y + points[0].y) * 0.5,
          };
          ctx.beginPath();
          ctx.moveTo(startMid.x, startMid.y);
          for (let i = 0; i < n; i += 1) {
            const curr = points[i];
            const next = points[(i + 1) % n];
            const mid = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };
            ctx.quadraticCurveTo(curr.x, curr.y, mid.x, mid.y);
          }
          ctx.closePath();
          ctx.stroke();
        }

        function drawSelectionRing(mode, geometryState) {
          if (!mode) return;
          const ringWidth = SELECTION_RING_WIDTH_CSS * getCanvasScale();
          ctx.save();
          ctx.translate(canvas.width / 2, canvas.height / 2);
          ctx.lineWidth = ringWidth * 1.15;
          ctx.lineJoin = "round";
          ctx.lineCap = "round";
          ctx.strokeStyle = "rgba(255, 38, 38, 0.95)";

          if (mode === "topDotResize") {
            strokeDotOutline(geometryState.topDot, geometryState.R, true, geometryState.padding);
            ctx.restore();
            return;
          }
          if (mode === "bottomDotResize") {
            strokeDotOutline(geometryState.bottomDot, geometryState.R, false, geometryState.padding);
            ctx.restore();
            return;
          }

          const highlightWhite = mode === "white";
          if (!highlightWhite && mode !== "black") {
            ctx.restore();
            return;
          }

          ctx.save();
          if (highlightWhite) {
            ctx.lineWidth = ringWidth * 2.1;
            ctx.beginPath();
            ctx.arc(0, 0, geometryState.R, 0, TAU);
            appendBlackRegionPath(geometryState.dividerPoints, geometryState.R);
            ctx.clip("evenodd");
          } else {
            ctx.lineWidth = ringWidth * 2.1;
            traceBlackRegionPath(geometryState.dividerPoints, geometryState.R);
            ctx.clip();
          }

          ctx.beginPath();
          ctx.arc(0, 0, geometryState.R, 0, TAU);
          ctx.stroke();
          traceSmoothDivider(geometryState.dividerPoints);
          ctx.stroke();
          ctx.restore();
          ctx.restore();
        }

        function draw() {
          resizeCanvasToDisplaySize();
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const w = canvas.width;
          const h = canvas.height;
          const cx = w / 2;
          const cy = h / 2;
          const g = geometry();
          const lineWidth = Math.max(2, g.R * 0.02);

          ctx.save();
          ctx.shadowColor = "rgba(0,0,0,0.28)";
          ctx.shadowBlur = Math.max(10, g.R * 0.08);
          ctx.shadowOffsetY = Math.max(6, g.R * 0.03);
          ctx.beginPath();
          ctx.arc(cx, cy, g.R, 0, TAU);
          ctx.fillStyle = "rgba(0,0,0,0)";
          ctx.fill();
          ctx.restore();

          ctx.save();
          ctx.translate(cx, cy);
          ctx.beginPath();
          ctx.arc(0, 0, g.R, 0, TAU);
          ctx.clip();

          ctx.fillStyle = COLORS.white;
          ctx.beginPath();
          ctx.arc(0, 0, g.R, 0, TAU);
          ctx.fill();

          ctx.fillStyle = COLORS.black;
          traceBlackRegionPath(g.dividerPoints, g.R);
          ctx.fill();

          ctx.fillStyle = COLORS.black;
          drawDeformedDot(g.topDot, g.R, true, g.padding);
          ctx.fillStyle = COLORS.white;
          drawDeformedDot(g.bottomDot, g.R, false, g.padding);

          ctx.restore();

          ctx.beginPath();
          ctx.arc(cx, cy, g.R, 0, TAU);
          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = "rgba(0,0,0,0.75)";
          ctx.stroke();

          if (drag.active) {
            drawSelectionRing(drag.mode, g);
          }

        }

        function buildSnapshotCanvas(size = 1800) {
          draw();
          renderDateStamps();
          const snapshot = document.createElement("canvas");
          snapshot.width = size;
          snapshot.height = size;
          const snapshotCtx = snapshot.getContext("2d", { alpha: false });
          const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#a87444";
          snapshotCtx.fillStyle = bgColor;
          snapshotCtx.fillRect(0, 0, size, size);

          const symbolFrame = size * 0.8;
          const symbolX = (size - symbolFrame) * 0.5;
          const symbolY = (size - symbolFrame) * 0.5;
          snapshotCtx.drawImage(canvas, symbolX, symbolY, symbolFrame, symbolFrame);

          const stamp = formatDisplayDate(new Date());
          const fontSize = Math.round(size * 0.05);
          const edgePadX = size * 0.055;
          const topPadY = size * 0.045;
          const bottomAnchorY = size * 0.965;
          snapshotCtx.font = `700 ${fontSize}px ${CONDENSED_FONT_STACK}`;
          snapshotCtx.textBaseline = "top";
          snapshotCtx.textAlign = "right";
          snapshotCtx.fillStyle = "rgba(246, 241, 230, 0.96)";
          snapshotCtx.fillText(stamp, size - edgePadX, topPadY);

          snapshotCtx.save();
          const stampWidth = snapshotCtx.measureText(stamp).width;
          snapshotCtx.translate(edgePadX + stampWidth, bottomAnchorY);
          snapshotCtx.rotate(Math.PI);
          snapshotCtx.textBaseline = "top";
          snapshotCtx.textAlign = "left";
          snapshotCtx.fillStyle = "rgba(17, 17, 17, 0.94)";
          snapshotCtx.fillText(stamp, 0, 0);
          snapshotCtx.restore();

          return snapshot;
        }

        function canvasToBlob(canvasNode) {
          return new Promise((resolve, reject) => {
            if (typeof canvasNode.toBlob !== "function") {
              try {
                const dataUrl = canvasNode.toDataURL("image/png");
                fetch(dataUrl)
                  .then((response) => response.blob())
                  .then(resolve)
                  .catch(reject);
                return;
              } catch (error) {
                reject(error);
                return;
              }
            }
            canvasNode.toBlob((blob) => {
              if (!blob) {
                reject(new Error("Could not create image blob"));
                return;
              }
              resolve(blob);
            }, "image/png");
          });
        }

        function downloadBlob(blob, fileName) {
          const url = URL.createObjectURL(blob);
          const link = document.createElement("a");
          link.href = url;
          link.download = fileName;
          document.body.append(link);
          link.click();
          link.remove();
          setTimeout(() => URL.revokeObjectURL(url), 1500);
        }

        async function shareSnapshot(blob, fileName) {
          if (!("share" in navigator)) return false;
          if (typeof File !== "function") return false;
          const file = new File([blob], fileName, { type: "image/png" });
          if ("canShare" in navigator && !navigator.canShare({ files: [file] })) return false;
          await navigator.share({
            title: "Mood snapshot",
            files: [file],
          });
          return true;
        }

        function openBlobInNewTab(blob) {
          const url = URL.createObjectURL(blob);
          const opened = window.open(url, "_blank", "noopener,noreferrer");
          setTimeout(() => URL.revokeObjectURL(url), 6000);
          return Boolean(opened);
        }

        async function captureMoodSymbol() {
          if (saveState.isSaving) return;
          saveState.isSaving = true;
          saveShotButton.disabled = true;
          saveShotButton.classList.add("is-saving");
          setSaveStatus("Saving...");

          try {
            const now = new Date();
            const fileStamp = formatFilenameStamp(now);
            const fileName = `Mood - ${fileStamp.date} - ${fileStamp.time}.png`;
            const snapshotCanvas = buildSnapshotCanvas();
            const blob = await canvasToBlob(snapshotCanvas);

            if (isIOSLike) {
              try {
                const shared = await shareSnapshot(blob, fileName);
                if (shared) {
                  setSaveStatus("Shared mood snapshot");
                  return;
                }
              } catch (error) {
                if (error?.name === "AbortError") {
                  setSaveStatus("Share canceled");
                  return;
                }
              }

              const opened = openBlobInNewTab(blob);
              if (opened) {
                setSaveStatus("Opened snapshot tab");
                return;
              }
            }

            downloadBlob(blob, fileName);
            setSaveStatus("Saved mood snapshot");
          } catch (error) {
            setSaveStatus("Couldnt save snapshot");
          } finally {
            saveShotButton.disabled = false;
            saveShotButton.classList.remove("is-saving");
            saveState.isSaving = false;
          }
        }

        function requestDraw() {
          if (requestDraw._raf) return;
          requestDraw._raf = requestAnimationFrame(() => {
            requestDraw._raf = 0;
            draw();
          });
        }

        canvas.addEventListener("pointerdown", (e) => {
          resizeCanvasToDisplaySize();
          const local = getLocalPoint(e);
          const g = geometry();
          if (!isInsideCircle(local.x, local.y, g.R)) return;

          drag.active = true;
          drag.pointerId = e.pointerId;
          drag.start = local;
          drag.last = local;
          drag.startWhitePush = state.whitePush;
          drag.startBlackPush = state.blackPush;
          drag.startWhiteLift = state.whiteLift;
          drag.startBlackLift = state.blackLift;
          drag.startWhiteLocalShiftX = state.whiteLocalShiftX;
          drag.startBlackLocalShiftX = state.blackLocalShiftX;
          drag.startWhiteFocusY = state.whiteFocusY;
          drag.startBlackFocusY = state.blackFocusY;
          drag.startTopScale = state.topDotScale;
          drag.startBottomScale = state.bottomDotScale;
          drag.grabYNorm = clamp(local.y / g.R, -1, 1);
          const influence = getGrabInfluence(drag.grabYNorm);
          drag.topInfluence = influence.top;
          drag.bottomInfluence = influence.bottom;
          drag.activeDotCenter = { x: 0, y: 0 };
          drag.activeDotStartDist = 0;

          const resizePad = DOT_RESIZE_INNER_PAD_CSS * getCanvasScale();
          const topDist = Math.hypot(local.x - g.topDot.x, local.y - g.topDot.y);
          const bottomDist = Math.hypot(local.x - g.bottomDot.x, local.y - g.bottomDot.y);
          const topResizeR = g.topDot.r + resizePad;
          const bottomResizeR = g.bottomDot.r + resizePad;
          const insideTopDot = topDist <= topResizeR;
          const insideBottomDot = bottomDist <= bottomResizeR;

          if (insideTopDot || insideBottomDot) {
            let selected = "top";
            if (!insideTopDot) {
              selected = "bottom";
            } else if (insideBottomDot) {
              const topNorm = topDist / Math.max(1e-6, topResizeR);
              const bottomNorm = bottomDist / Math.max(1e-6, bottomResizeR);
              selected = topNorm <= bottomNorm ? "top" : "bottom";
            }
            drag.mode = selected === "top" ? "topDotResize" : "bottomDotResize";
            drag.activeDotCenter =
              selected === "top" ? { x: g.topDot.x, y: g.topDot.y } : { x: g.bottomDot.x, y: g.bottomDot.y };
            drag.activeDotStartDist = selected === "top" ? topDist : bottomDist;
          } else {
            drag.mode = isWhiteAt(local.x, local.y, g.R) ? "white" : "black";
          }

          if (drag.mode === "white") {
            state.whiteFocusY = drag.grabYNorm;
            drag.startWhiteFocusY = state.whiteFocusY;
          } else if (drag.mode === "black") {
            state.blackFocusY = drag.grabYNorm;
            drag.startBlackFocusY = state.blackFocusY;
          }

          canvas.setPointerCapture(e.pointerId);
        });

        canvas.addEventListener("pointermove", (e) => {
          if (!drag.active || e.pointerId !== drag.pointerId) return;
          resizeCanvasToDisplaySize();
          const local = getLocalPoint(e);
          const R = getRadius();
          const dx = local.x - drag.start.x;
          const dy = local.y - drag.start.y;

          if (drag.mode === "white" || drag.mode === "black") {
            const localHorizontal = dx / (0.72 * R);
            const localVertical = dy / (0.5 * R);
            const globalHorizontal = dx / (1.38 * R);
            const globalVertical = dy / (0.56 * R);
            const verticalRatioDrive = globalVertical * 0.26;

            if (drag.mode === "white") {
              const topGain = 0.35 + 1.15 * drag.topInfluence;
              const bottomGain = 0.18 + 0.36 * drag.bottomInfluence;

              state.whiteLocalShiftX = clamp(
                drag.startWhiteLocalShiftX + localHorizontal * 1.06,
                -1.55,
                1.55
              );
              state.whiteFocusY = clamp(drag.startWhiteFocusY + localVertical * 1.35, -1.18, 1.18);
              state.whitePush = clamp(
                drag.startWhitePush + globalHorizontal * topGain + verticalRatioDrive * 0.62,
                0,
                1
              );
              state.blackPush = clamp(
                drag.startBlackPush -
                  globalHorizontal * bottomGain * 0.42 -
                  verticalRatioDrive * 0.58,
                0,
                1
              );
              state.whiteLift = clamp(
                drag.startWhiteLift + globalVertical * (1.35 + 0.8 * drag.topInfluence),
                -1.45,
                1.45
              );
              state.blackLift = clamp(
                drag.startBlackLift + globalVertical * (0.06 + 0.14 * drag.bottomInfluence),
                -1.45,
                1.45
              );
            } else {
              const bottomGain = 0.35 + 1.15 * drag.bottomInfluence;
              const topGain = 0.18 + 0.36 * drag.topInfluence;

              state.blackLocalShiftX = clamp(
                drag.startBlackLocalShiftX - localHorizontal * 1.06,
                -1.55,
                1.55
              );
              state.blackFocusY = clamp(drag.startBlackFocusY + localVertical * 1.35, -1.18, 1.18);
              state.blackPush = clamp(
                drag.startBlackPush - globalHorizontal * bottomGain + verticalRatioDrive * 0.62,
                0,
                1
              );
              state.whitePush = clamp(
                drag.startWhitePush + globalHorizontal * topGain * 0.42 + verticalRatioDrive * 0.58,
                0,
                1
              );
              state.blackLift = clamp(
                drag.startBlackLift + globalVertical * (1.35 + 0.8 * drag.bottomInfluence),
                -1.45,
                1.45
              );
              state.whiteLift = clamp(
                drag.startWhiteLift + globalVertical * (0.06 + 0.14 * drag.topInfluence),
                -1.45,
                1.45
              );
            }
            drag.last = local;
          } else if (drag.mode === "topDotResize") {
            const currentDist = Math.hypot(
              local.x - drag.activeDotCenter.x,
              local.y - drag.activeDotCenter.y
            );
            const radialDelta = currentDist - drag.activeDotStartDist;
            state.topDotScale = clamp(drag.startTopScale + radialDelta / (0.46 * R), 0.04, 7.4);
            const overflow = Math.max(0, state.topDotScale - 3.1);
            const deformT = clamp(overflow / 3.4, 0, 1);
            state.whitePush = clamp(drag.startWhitePush + deformT * 0.35, 0, 1);
            state.blackPush = clamp(drag.startBlackPush - deformT * 0.35, 0, 1);
            state.whiteLift = clamp(drag.startWhiteLift - deformT * 0.12, -1.45, 1.45);
            state.blackLift = clamp(drag.startBlackLift - deformT * 0.03, -1.45, 1.45);
          } else if (drag.mode === "bottomDotResize") {
            const currentDist = Math.hypot(
              local.x - drag.activeDotCenter.x,
              local.y - drag.activeDotCenter.y
            );
            const radialDelta = currentDist - drag.activeDotStartDist;
            state.bottomDotScale = clamp(drag.startBottomScale + radialDelta / (0.46 * R), 0.04, 7.4);
            const overflow = Math.max(0, state.bottomDotScale - 3.1);
            const deformT = clamp(overflow / 3.4, 0, 1);
            state.blackPush = clamp(drag.startBlackPush + deformT * 0.35, 0, 1);
            state.whitePush = clamp(drag.startWhitePush - deformT * 0.35, 0, 1);
            state.blackLift = clamp(drag.startBlackLift + deformT * 0.12, -1.45, 1.45);
            state.whiteLift = clamp(drag.startWhiteLift + deformT * 0.03, -1.45, 1.45);
          }

          requestDraw();
        });

        function endDrag(e) {
          if (!drag.active || e.pointerId !== drag.pointerId) return;
          drag.active = false;
          drag.pointerId = null;
          drag.mode = null;
          requestDraw();
        }

        canvas.addEventListener("pointerup", endDrag);
        canvas.addEventListener("pointercancel", endDrag);
        window.addEventListener("resize", requestDraw, { passive: true });
        saveShotButton.addEventListener("click", captureMoodSymbol);
        window.addEventListener("keydown", (event) => {
          if (event.code !== "Space" || event.repeat) return;
          const activeTag = (document.activeElement?.tagName || "").toLowerCase();
          if (activeTag === "input" || activeTag === "textarea" || activeTag === "select") return;
          event.preventDefault();
          captureMoodSymbol();
        });

        requestDraw();
      })();
    </script>
  </body>
</html>
