
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <title>Duality tracker</title>
    <style>
      :root {
        --bg: #a87444;
        --black: #111111;
        --white: #f6f1e6;
        --text-subtle: rgba(73, 45, 23, 0.72);
        --text-subtle-soft: rgba(73, 45, 23, 0.6);
        --condensed:
          "Futura-CondensedExtraBold", "Futura Condensed", "Avenir Next Condensed",
          "Arial Narrow", "Roboto Condensed", "Impact", sans-serif;
      }

      html,
      body {
        height: 100%;
      }

      body {
        margin: 0;
        background: var(--bg);
        min-height: 100svh;
        min-height: 100dvh;
        overscroll-behavior: none;
        -webkit-text-size-adjust: 100%;
        display: grid;
        place-items: center;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      }

      .app {
        width: min(96vw, 980px);
        min-height: 100svh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        gap: clamp(12px, 2.2vh, 24px);
        padding: calc(10px + env(safe-area-inset-top)) 0 calc(6px + env(safe-area-inset-bottom));
        box-sizing: border-box;
      }

      .instruction {
        margin: 0;
        max-width: 68ch;
        text-align: center;
        font-size: clamp(10px, 1.02vw, 11px);
        line-height: 1.3;
        letter-spacing: 0.01em;
        color: rgba(73, 45, 23, 0.46);
      }

      .symbol-stage {
        width: min(88vw, 74svh, 760px);
        position: relative;
        margin-top: auto;
      }

      .wrap {
        width: 100%;
        aspect-ratio: 1;
        display: grid;
        place-items: center;
      }

      .date-stamp {
        position: absolute;
        z-index: 2;
        font-family: var(--condensed);
        font-size: clamp(14px, 2.8vmin, 30px);
        font-weight: 700;
        line-height: 1;
        letter-spacing: 0.028em;
        text-transform: uppercase;
        user-select: none;
        pointer-events: none;
      }

      .date-top {
        top: -3.6%;
        right: -2.8%;
        color: rgba(246, 241, 230, 0.96);
      }

      .date-bottom {
        bottom: -3.6%;
        left: -2.8%;
        transform: rotate(180deg);
        transform-origin: center;
        color: rgba(17, 17, 17, 0.94);
      }

      .meta {
        width: min(94vw, 760px);
        display: grid;
        justify-items: center;
        gap: 5px;
        margin-top: auto;
        margin-bottom: 2px;
      }

      .instruction-row {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        font-size: clamp(10px, 1.02vw, 11px);
        margin-top: 0;
      }

      .instruction-row .instruction {
        max-width: 68ch;
        white-space: normal;
      }

      .button-row {
        display: grid;
        place-items: center;
        width: 100%;
      }

      .shot-btn {
        border: 1px solid rgba(73, 45, 23, 0.34);
        background: transparent;
        color: rgba(73, 45, 23, 0.44);
        border-radius: 999px;
        padding: 3px 10px;
        font-family: inherit;
        font-size: clamp(10px, 1.02vw, 11px);
        font-weight: 400;
        letter-spacing: 0.01em;
        line-height: 1.2;
        cursor: pointer;
        appearance: none;
        -webkit-appearance: none;
        transition: background-color 120ms ease, color 120ms ease, border-color 120ms ease;
      }

      .shot-btn:hover {
        background: rgba(73, 45, 23, 0.08);
      }

      .shot-btn:active {
        background: rgba(73, 45, 23, 0.12);
      }

      .shot-btn.is-saving {
        opacity: 0.75;
      }

      .shot-btn:focus-visible {
        outline: 2px solid rgba(17, 17, 17, 0.4);
        outline-offset: 2px;
      }

      .save-status {
        min-height: 1em;
        margin: 0;
        font-size: clamp(9px, 0.92vw, 10px);
        color: rgba(73, 45, 23, 0.38);
      }

      canvas {
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
        -webkit-tap-highlight-color: transparent;
      }

      @media (max-width: 760px) {
        .app {
          position: relative;
          gap: 10px;
          justify-content: center;
          padding-top: calc(8px + env(safe-area-inset-top));
          padding-bottom: calc(10px + env(safe-area-inset-bottom));
        }

        .symbol-stage {
          width: min(94vw, 70svh, 620px);
          margin-top: 0;
        }

        .date-stamp {
          font-size: clamp(18px, 4.1vmin, 28px);
        }

        .date-top {
          top: -5.4%;
          right: -2.4%;
        }

        .date-bottom {
          bottom: -5.4%;
          left: -2.4%;
        }

        .meta {
          position: absolute;
          left: 50%;
          transform: translateX(-50%);
          bottom: calc(6px + env(safe-area-inset-bottom));
          width: min(98vw, 680px);
          gap: 4px;
          margin: 0;
        }

        .instruction {
          font-size: clamp(8px, 2.45vw, 11px);
          color: rgba(73, 45, 23, 0.78);
          white-space: nowrap;
        }

        .instruction-row .instruction {
          max-width: 98vw;
        }

        .shot-btn {
          font-size: clamp(8px, 2.45vw, 11px);
          color: rgba(73, 45, 23, 0.74);
          border-color: rgba(73, 45, 23, 0.58);
          padding: 3px 11px;
        }
      }
    </style>
  </head>
  <body>
    <main class="app">
      <section class="symbol-stage" aria-label="Duality symbol with date">
        <div class="date-stamp date-top" id="dateTop"></div>
        <section class="wrap">
          <canvas id="yy" aria-label="Interactive yin yang mood tracker"></canvas>
        </section>
        <div class="date-stamp date-bottom" id="dateBottom"></div>
      </section>
      <section class="meta">
        <p class="instruction">
          Click and drag on each unique element of the symbol
        </p>
        <p class="instruction">make it reflect the balance of light and dark within you today</p>
        <div class="instruction-row">
          <p class="instruction">take a screenshot to track your daily moods and perceptions of self</p>
        </div>
        <div class="button-row">
          <button class="shot-btn" id="saveShot" type="button">screenshot</button>
        </div>
        <p class="save-status" id="saveStatus" aria-live="polite"></p>
      </section>
    </main>

    <script>
      (() => {
        const TAU = Math.PI * 2;
        const canvas = document.getElementById("yy");
        const dateTop = document.getElementById("dateTop");
        const dateBottom = document.getElementById("dateBottom");
        const saveShotButton = document.getElementById("saveShot");
        const saveStatus = document.getElementById("saveStatus");
        const ctx = canvas.getContext("2d", { alpha: true });
        const rootStyles = getComputedStyle(document.documentElement);
        const CONDENSED_FONT_STACK =
          '"Futura-CondensedExtraBold","Futura Condensed","Avenir Next Condensed","Arial Narrow","Roboto Condensed","Impact",sans-serif';
        const isIOSLike =
          /iPad|iPhone|iPod/.test(navigator.userAgent) ||
          (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
        const saveState = {
          isSaving: false,
          statusTimeout: 0,
        };

        function formatDisplayDate(date = new Date()) {
          const parts = new Intl.DateTimeFormat("en-US", {
            month: "short",
            day: "numeric",
            year: "numeric",
          }).formatToParts(date);
          const month = (parts.find((part) => part.type === "month")?.value || "").toUpperCase();
          const day = parts.find((part) => part.type === "day")?.value || "";
          const year = parts.find((part) => part.type === "year")?.value || "";
          return `${month} ${day} ${year}`.trim();
        }

        function renderDateStamps() {
          const stamp = formatDisplayDate(new Date());
          dateTop.textContent = stamp;
          dateBottom.textContent = stamp;
        }
        renderDateStamps();
        window.setInterval(renderDateStamps, 60_000);

        function formatFilenameStamp(date = new Date()) {
          const year = String(date.getFullYear());
          const month = String(date.getMonth() + 1).padStart(2, "0");
          const day = String(date.getDate()).padStart(2, "0");
          const hour = String(date.getHours()).padStart(2, "0");
          const minute = String(date.getMinutes()).padStart(2, "0");
          const second = String(date.getSeconds()).padStart(2, "0");
          return {
            date: `${year}-${month}-${day}`,
            time: `${hour}-${minute}-${second}`,
          };
        }

        function setSaveStatus(message) {
          saveStatus.textContent = message;
          if (saveState.statusTimeout) {
            clearTimeout(saveState.statusTimeout);
            saveState.statusTimeout = 0;
          }
          if (!message) return;
          saveState.statusTimeout = window.setTimeout(() => {
            saveStatus.textContent = "";
            saveState.statusTimeout = 0;
          }, 2600);
        }

        const COLORS = {
          black: getComputedStyle(document.documentElement).getPropertyValue("--black").trim(),
          white: getComputedStyle(document.documentElement).getPropertyValue("--white").trim(),
        };
        const DOT_PADDING_CSS = 5;
        const DOT_DRAG_HIT_PAD_CSS = 6;
        const PUSH_MIN = 0.005;
        const PUSH_MAX = 0.995;

        const state = {
          whitePush: 0.5,
          blackPush: 0.5,
          whiteLift: 0,
          blackLift: 0,
          whiteLocalShiftX: 0,
          blackLocalShiftX: 0,
          whiteFocusY: -0.5,
          blackFocusY: 0.5,
        };
        const stateTarget = { ...state };
        const STATE_KEYS = Object.keys(state);

        const SELECTION_RING_WIDTH_CSS = 6;

        const drag = {
          active: false,
          pointerId: null,
          mode: null, // "white" | "black" | "topDotMove" | "bottomDotMove"
          start: { x: 0, y: 0 },
          last: { x: 0, y: 0 },
          startWhitePush: 0.5,
          startBlackPush: 0.5,
          startWhiteLift: 0,
          startBlackLift: 0,
          startWhiteLocalShiftX: 0,
          startBlackLocalShiftX: 0,
          startWhiteFocusY: -0.5,
          startBlackFocusY: 0.5,
          grabYNorm: 0,
          topInfluence: 0.5,
          bottomInfluence: 0.5,
          activeDotCenter: { x: 0, y: 0 },
          activeDotOffset: { x: 0, y: 0 },
        };

        const dotMemory = {
          top: null,
          bottom: null,
        };

        const dotUser = {
          top: { active: false, x: 0, y: -0.5 },
          bottom: { active: false, x: 0, y: 0.5 },
        };

        function clamp(n, min, max) {
          return Math.min(max, Math.max(min, n));
        }

        function clampPush(value) {
          return clamp(value, PUSH_MIN, PUSH_MAX);
        }

        function setDotUserPosition(key, x, y, R) {
          const safeR = Math.max(1e-6, R);
          dotUser[key].active = true;
          dotUser[key].x = clamp(x / safeR, -1.2, 1.2);
          dotUser[key].y = clamp(y / safeR, -1.2, 1.2);
        }

        function getDotUserPosition(key, R) {
          const safeR = Math.max(1e-6, R);
          return { x: dotUser[key].x * safeR, y: dotUser[key].y * safeR };
        }

        function dividerSlopeAtY(y, R) {
          const h = Math.max(1, R * 0.006);
          const y0 = clamp(y - h, -R, R);
          const y1 = clamp(y + h, -R, R);
          const dy = Math.max(1e-6, y1 - y0);
          return (dividerXAtY(y1, R) - dividerXAtY(y0, R)) / dy;
        }

        function dividerNormalDistance(x, y, R) {
          const dx = x - dividerXAtY(y, R);
          const slope = dividerSlopeAtY(y, R);
          return Math.abs(dx) / Math.sqrt(1 + slope * slope);
        }

        function easeStateTowardTarget() {
          let moving = false;
          for (let i = 0; i < STATE_KEYS.length; i += 1) {
            const key = STATE_KEYS[i];
            const current = state[key];
            const target = stateTarget[key];
            const delta = target - current;
            if (Math.abs(delta) <= 1e-4) {
              state[key] = target;
              continue;
            }
            const follow = drag.active ? 0.3 : 0.2;
            state[key] = current + delta * follow;
            if (Math.abs(target - state[key]) <= 1e-4) {
              state[key] = target;
            } else {
              moving = true;
            }
          }
          return moving;
        }

        function getGrabInfluence(yNorm) {
          const yn = clamp(yNorm, -1, 1);
          const sigma = 0.46;
          const topRaw = Math.exp(-Math.pow((yn + 0.52) / sigma, 2));
          const bottomRaw = Math.exp(-Math.pow((yn - 0.52) / sigma, 2));
          const sum = topRaw + bottomRaw + 1e-9;
          return { top: topRaw / sum, bottom: bottomRaw / sum };
        }

        function resizeCanvasToDisplaySize() {
          const rect = canvas.getBoundingClientRect();
          const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
          const w = Math.max(2, Math.round(rect.width * dpr));
          const h = Math.max(2, Math.round(rect.height * dpr));
          if (canvas.width !== w || canvas.height !== h) {
            canvas.width = w;
            canvas.height = h;
          }
        }

        function getLocalPoint(e) {
          const rect = canvas.getBoundingClientRect();
          const sx = canvas.width / rect.width;
          const sy = canvas.height / rect.height;
          const x = (e.clientX - rect.left) * sx;
          const y = (e.clientY - rect.top) * sy;
          return { x: x - canvas.width / 2, y: y - canvas.height / 2 };
        }

        function getRadius() {
          return Math.min(canvas.width, canvas.height) * 0.44;
        }

        function getCanvasScale() {
          return canvas.width / Math.max(1, canvas.clientWidth || 1);
        }

        function isInsideCircle(x, y, R) {
          return x * x + y * y <= R * R;
        }

        function getLobeCoefficients() {
          const whiteDelta = (state.whitePush - 0.5) * 2;
          const blackDelta = (state.blackPush - 0.5) * 2;
          const topDrive = 1.36 * whiteDelta - 0.66 * blackDelta;
          const bottomDrive = 1.36 * blackDelta - 0.66 * whiteDelta;
          const topCoeff = clamp(0.5 * Math.exp(topDrive), 0.12, 1.45);
          const bottomCoeff = clamp(0.5 * Math.exp(bottomDrive), 0.12, 1.45);
          return { whiteDelta, blackDelta, topCoeff, bottomCoeff };
        }

        function getLobeCenters(R) {
          const half = R * 0.5;
          let topCenter = -half + state.whiteLift * 0.94 * R;
          let bottomCenter = half + state.blackLift * 0.94 * R;

          topCenter = clamp(topCenter, -1.14 * R, 0.92 * R);
          bottomCenter = clamp(bottomCenter, -0.92 * R, 1.14 * R);

          const minGap = 0.08 * R;
          const maxGap = 1.9 * R;
          let gap = bottomCenter - topCenter;
          if (gap < minGap) {
            const spread = (minGap - gap) * 0.5;
            topCenter -= spread;
            bottomCenter += spread;
          } else if (gap > maxGap) {
            const compress = (gap - maxGap) * 0.5;
            topCenter += compress;
            bottomCenter -= compress;
          }
          gap = bottomCenter - topCenter;
          if (gap < minGap) {
            const mid = (topCenter + bottomCenter) * 0.5;
            topCenter = mid - minGap * 0.5;
            bottomCenter = mid + minGap * 0.5;
          }

          return { topCenter, bottomCenter };
        }

        function baseDividerX(y, R) {
          const half = R * 0.5;
          if (y <= 0) {
            const dy = y + half;
            return Math.sqrt(Math.max(0, half * half - dy * dy));
          }
          const dy = y - half;
          return -Math.sqrt(Math.max(0, half * half - dy * dy));
        }

        function dividerXAtY(y, R) {
          const t = y / R;
          const { whiteDelta, blackDelta, topCoeff, bottomCoeff } = getLobeCoefficients();
          const { topCenter, bottomCenter } = getLobeCenters(R);
          const dominance = clamp(state.whitePush - state.blackPush, -1, 1);
          const dominanceAbs = Math.abs(dominance);
          const outerX = Math.sqrt(Math.max(0, R * R - y * y));

          const base = baseDividerX(y, R);
          const sigma = 0.39 * R;
          const topProfile = Math.exp(-Math.pow((y - topCenter) / sigma, 2));
          const bottomProfile = Math.exp(-Math.pow((y - bottomCenter) / sigma, 2));
          const middleProfile = Math.exp(-Math.pow(y / (0.52 * R), 2));
          const envelope = Math.pow(Math.max(0, 1 - t * t), 1.25);
          const edgeEnvelope = 0.3 + 0.7 * envelope;
          const dominanceBoost = 1 + 2.2 * Math.pow(dominanceAbs, 2.1);

          const topDrive = topCoeff - 0.5;
          const bottomDrive = bottomCoeff - 0.5;
          let deform =
            0.78 * topDrive * topProfile -
            0.78 * bottomDrive * bottomProfile +
            0.2 * (topDrive - bottomDrive) * middleProfile +
            0.52 * state.whiteLift * topProfile -
            0.52 * state.blackLift * bottomProfile +
            0.34 * (state.whiteLift - state.blackLift) * t;
          deform *= envelope * R;

          const localSigma = 0.36 * R;
          const whiteLocalCenter = clamp(
            (state.whiteFocusY + state.whiteLift * 0.08) * R,
            -0.95 * R,
            0.95 * R
          );
          const blackLocalCenter = clamp(
            (state.blackFocusY + state.blackLift * 0.08) * R,
            -0.95 * R,
            0.95 * R
          );
          const whiteLocalProfile = Math.exp(-Math.pow((y - whiteLocalCenter) / localSigma, 2));
          const blackLocalProfile = Math.exp(-Math.pow((y - blackLocalCenter) / localSigma, 2));
          const localDeform =
            (0.48 * state.whiteLocalShiftX * whiteLocalProfile -
              0.48 * state.blackLocalShiftX * blackLocalProfile) *
            edgeEnvelope *
            envelope *
            R;

          let x = base + deform + localDeform;
          const dominanceShift =
            dominance * outerX * (0.66 + 0.1 * middleProfile) * edgeEnvelope * dominanceBoost;
          x += dominanceShift;

          const limit = outerX * 0.9992;
          if (limit <= 1e-9) return 0;
          x = limit * Math.tanh(x / (limit + 1e-9));
          return x;
        }

        function getGlobalDeformAmount() {
          const pushDelta =
            Math.max(Math.abs(state.whitePush - 0.5), Math.abs(state.blackPush - 0.5)) * 2;
          const liftDelta = Math.max(Math.abs(state.whiteLift), Math.abs(state.blackLift));
          return clamp(Math.max(pushDelta, liftDelta), 0, 1);
        }

        function smoothDividerPoints(points, passes = 2) {
          if (points.length < 5 || passes <= 0) return points;
          let xs = points.map((point) => point.x);
          const n = xs.length;

          for (let pass = 0; pass < passes; pass += 1) {
            const next = xs.slice();
            for (let i = 2; i < n - 2; i += 1) {
              next[i] =
                (xs[i - 2] + 4 * xs[i - 1] + 6 * xs[i] + 4 * xs[i + 1] + xs[i + 2]) / 16;
            }
            next[1] = (xs[0] + 2 * xs[1] + xs[2]) * 0.25;
            next[n - 2] = (xs[n - 3] + 2 * xs[n - 2] + xs[n - 1]) * 0.25;
            xs = next;
          }

          return points.map((point, index) => ({ x: xs[index], y: point.y }));
        }

        function buildDivider(R, globalDeform, steps = 680) {
          const points = [];
          for (let i = 0; i <= steps; i += 1) {
            const y = -R + (2 * R * i) / steps;
            points.push({ x: dividerXAtY(y, R), y });
          }
          const smoothPasses = globalDeform < 0.04 ? 1 : 3;
          return smoothDividerPoints(points, smoothPasses);
        }

        function dividerXFromPointsAtY(dividerPoints, y, R) {
          const points = dividerPoints;
          if (!points || points.length < 2) return dividerXAtY(y, R);
          if (y <= -R) return points[0].x;
          if (y >= R) return points[points.length - 1].x;

          const normalized = (y + R) / (2 * R);
          const t = normalized * (points.length - 1);
          const i0 = Math.floor(t);
          const i1 = Math.min(points.length - 1, i0 + 1);
          const localT = t - i0;
          const p0 = points[i0];
          const p1 = points[i1];
          return p0.x + (p1.x - p0.x) * localT;
        }

        function dividerSlopeFromPointsAtY(dividerPoints, y, R) {
          const points = dividerPoints;
          if (!points || points.length < 2) return dividerSlopeAtY(y, R);
          const sampleStep = (2 * R) / Math.max(32, points.length - 1);
          const y0 = clamp(y - sampleStep, -R, R);
          const y1 = clamp(y + sampleStep, -R, R);
          const dy = Math.max(1e-6, y1 - y0);
          const x0 = dividerXFromPointsAtY(points, y0, R);
          const x1 = dividerXFromPointsAtY(points, y1, R);
          return (x1 - x0) / dy;
        }

        function dividerNormalDistanceFromPoints(x, y, R, dividerPoints) {
          const points = dividerPoints;
          if (!points || points.length < 2) return dividerNormalDistance(x, y, R);
          const dx = x - dividerXFromPointsAtY(points, y, R);
          const slope = dividerSlopeFromPointsAtY(points, y, R);
          return Math.abs(dx) / Math.sqrt(1 + slope * slope);
        }

        function isWhiteAt(x, y, R, dividerPoints = null) {
          const dividerX = dividerPoints
            ? dividerXFromPointsAtY(dividerPoints, y, R)
            : dividerXAtY(y, R);
          return x <= dividerX;
        }

        function findDotAuto(
          R,
          region,
          padding,
          lobeCenters,
          stackAxisX,
          dividerPoints
        ) {
          const isTop = region === "top";
          const dominance = clamp(state.whitePush - state.blackPush, -1, 1);
          const lift = isTop ? state.whiteLift : state.blackLift;
          const focusRaw = isTop ? state.whiteFocusY : state.blackFocusY;
          const focusClamped = isTop ? clamp(focusRaw, -0.95, 0.2) : clamp(focusRaw, -0.2, 0.95);
          const baseAnchorY = isTop ? -0.44 * R : 0.44 * R;
          const lobeCenterY = isTop ? lobeCenters.topCenter : lobeCenters.bottomCenter;
          const preferredY = clamp(
            baseAnchorY +
              lift * 0.38 * R +
              focusClamped * 0.08 * R +
              (lobeCenterY - baseAnchorY) * 0.24,
            isTop ? -0.95 * R : -0.22 * R,
            isTop ? 0.22 * R : 0.95 * R
          );

          const getHostRangeAtY = (y) => {
            const outer = Math.sqrt(Math.max(0, R * R - y * y));
            const divider = clamp(dividerXFromPointsAtY(dividerPoints, y, R), -outer, outer);
            const left = isTop ? -outer : divider;
            const right = isTop ? divider : outer;
            return { left, right, span: Math.max(0, right - left) };
          };

          const yAnchor = preferredY;
          const hostAtAnchor = getHostRangeAtY(preferredY);
          const xAnchor =
            stackAxisX * 0.86 +
            (hostAtAnchor.left + hostAtAnchor.right) * 0.14 +
            dominance * (isTop ? 0.015 : -0.015) * R;
          const spanX = 0.88 * R;
          const spanY = 0.92 * R;
          const cols = 42;
          const rows = 42;
          const yMin = Math.max(isTop ? -R : -0.24 * R, yAnchor - spanY * 0.5);
          const yMax = Math.min(isTop ? 0.24 * R : R, yAnchor + spanY * 0.5);

          let best = null;
          const pool = [];

          for (let iy = 0; iy <= rows; iy += 1) {
            const y = yMin + ((yMax - yMin) * iy) / rows;
            const outer = Math.sqrt(Math.max(0, R * R - y * y));
            for (let ix = 0; ix <= cols; ix += 1) {
              const x = xAnchor - spanX * 0.5 + (spanX * ix) / cols;
              if (Math.abs(x) >= outer) continue;

              const white = isWhiteAt(x, y, R, dividerPoints);
              if ((isTop && !white) || (!isTop && white)) continue;

              const dOuter = R - Math.hypot(x, y);
              const dDivider = dividerNormalDistanceFromPoints(x, y, R, dividerPoints);
              const maxR = Math.min(dOuter, dDivider) - padding;
              if (maxR <= 0) continue;

              const roomN = maxR / R;
              const depthN = dDivider / R;
              const verticalN = 1 - clamp(Math.abs(y - yAnchor) / (0.52 * R), 0, 1);
              const anchorN = 1 - clamp(Math.hypot((x - xAnchor) / (0.64 * R), (y - yAnchor) / (0.52 * R)), 0, 1);
              const stackN = 1 - clamp(Math.abs(x - stackAxisX) / (0.34 * R), 0, 1);
              const score =
                1.92 * roomN + 0.2 * depthN + 0.2 * verticalN + 0.15 * anchorN + 1.05 * stackN;
              const candidate = { x, y, maxR, score };
              pool.push(candidate);

              if (!best || score > best.score) {
                best = candidate;
              }
            }
          }

          if (!best) {
            return { x: xAnchor, y: yAnchor, r: R * 0.08, room: R * 0.08 };
          }

          let chosen = best;
          if (pool.length > 1) {
            const cutoff = best.score - 0.07;
            let wSum = 0;
            let xSum = 0;
            let ySum = 0;
            let roomSum = 0;
            for (let i = 0; i < pool.length; i += 1) {
              const candidate = pool[i];
              if (candidate.score < cutoff) continue;
              const weight = Math.exp((candidate.score - best.score) * 11);
              wSum += weight;
              xSum += candidate.x * weight;
              ySum += candidate.y * weight;
              roomSum += candidate.maxR * weight;
            }
            if (wSum > 1e-6) {
              chosen = {
                x: xSum / wSum,
                y: ySum / wSum,
                maxR: roomSum / wSum,
                score: best.score,
              };
            }
          }

          const maxAllowed = Math.min(chosen.maxR * 0.42, R * 0.2);
          const minAllowed = Math.min(R * 0.008, maxAllowed);
          return {
            x: chosen.x,
            y: chosen.y,
            r: clamp(chosen.maxR * 0.24, minAllowed, maxAllowed),
            room: chosen.maxR,
          };
        }

        function getDotRoomAt(x, y, R, isTop, padding, dividerPoints) {
          if (!isInsideCircle(x, y, R)) return 0;
          const white = isWhiteAt(x, y, R, dividerPoints);
          if ((isTop && !white) || (!isTop && white)) return 0;
          const dOuter = R - Math.hypot(x, y);
          const dividerX = dividerXFromPointsAtY(dividerPoints, y, R);
          const dDivider = Math.abs(x - dividerX);
          const coarseRoom = Math.max(0, Math.min(dOuter, dDivider) - padding);

          const raySamples = 20;
          let nearestEdge = Infinity;
          for (let i = 0; i < raySamples; i += 1) {
            const angle = (i / raySamples) * TAU;
            const dirX = Math.cos(angle);
            const dirY = Math.sin(angle);
            const boundaryDist = rayBoundaryDistance(x, y, dirX, dirY, R, isTop, dividerPoints);
            nearestEdge = Math.min(nearestEdge, boundaryDist);
          }
          const sampledRoom = Math.max(0, nearestEdge - padding);
          return coarseRoom * 0.2 + sampledRoom * 0.8;
        }

        function constrainDotToBlob(targetX, targetY, R, r, isTop, padding, dividerPoints) {
          const safePadding = padding;
          const safeOuterR = Math.max(0, R - (r + safePadding));
          const steps = 260;
          let best = null;

          for (let i = 0; i <= steps; i += 1) {
            const y = -safeOuterR + (2 * safeOuterR * i) / steps;
            const outerX = Math.sqrt(Math.max(0, safeOuterR * safeOuterR - y * y));
            const dividerX = dividerXFromPointsAtY(dividerPoints, y, R);
            const wall = r + safePadding;
            let left = -outerX;
            let right = outerX;

            if (isTop) {
              right = Math.min(right, dividerX - wall);
            } else {
              left = Math.max(left, dividerX + wall);
            }
            if (right < left) continue;

            const x = clamp(targetX, left, right);
            const distSq = (x - targetX) * (x - targetX) + (y - targetY) * (y - targetY);
            if (!best || distSq < best.distSq) {
              best = { x, y, distSq };
            }
          }

          if (!best) {
            return null;
          }
          return { x: best.x, y: best.y };
        }

        function constrainDotXAtY(targetX, y, R, r, isTop, padding, dividerPoints) {
          const safePadding = padding;
          const safeOuterR = Math.max(0, R - (r + safePadding));
          if (Math.abs(y) > safeOuterR) return null;
          const outerX = Math.sqrt(Math.max(0, safeOuterR * safeOuterR - y * y));
          const dividerX = dividerXFromPointsAtY(dividerPoints, y, R);
          const wall = r + safePadding;
          let left = -outerX;
          let right = outerX;
          if (isTop) {
            right = Math.min(right, dividerX - wall);
          } else {
            left = Math.max(left, dividerX + wall);
          }
          if (right < left) return null;
          return clamp(targetX, left, right);
        }

        function fitDotInsideBlob(dot, R, isTop, padding, dividerPoints) {
          let radius = Math.max(0.35, dot.r);
          let point = constrainDotToBlob(dot.x, dot.y, R, radius, isTop, padding, dividerPoints);

          for (let i = 0; i < 8 && !point; i += 1) {
            radius *= 0.84;
            point = constrainDotToBlob(dot.x, dot.y, R, radius, isTop, padding, dividerPoints);
          }

          if (!point) {
            const fallbackY = isTop ? -0.5 * R : 0.5 * R;
            const fallbackX = dividerXFromPointsAtY(dividerPoints, 0, R);
            radius = Math.max(0.35, Math.min(radius, R * 0.035));
            point = constrainDotToBlob(
              fallbackX,
              fallbackY,
              R,
              radius,
              isTop,
              padding,
              dividerPoints
            );
          }

          if (!point) {
            point = { x: dot.x, y: dot.y };
          }

          return { x: point.x, y: point.y, r: radius };
        }

        function stabilizeDotCenter(targetDot, key, R, isTop, padding, dividerPoints) {
          const memory = dotMemory[key];
          const fittedTarget = fitDotInsideBlob(targetDot, R, isTop, padding, dividerPoints);

          if (!memory) {
            dotMemory[key] = { x: fittedTarget.x, y: fittedTarget.y, r: fittedTarget.r };
            return fittedTarget;
          }

          const isDraggingDot =
            (key === "top" && drag.active && drag.mode === "topDotMove") ||
            (key === "bottom" && drag.active && drag.mode === "bottomDotMove");
          const distN =
            Math.hypot(fittedTarget.x - memory.x, fittedTarget.y - memory.y) / Math.max(1e-6, R);
          const follow = isDraggingDot
            ? clamp(0.74 + distN * 0.18, 0.74, 0.92)
            : clamp(0.14 + distN * 0.3, 0.14, 0.42);
          const rFollow = isDraggingDot ? 0.72 : 0.3;

          memory.x += (fittedTarget.x - memory.x) * follow;
          memory.y += (fittedTarget.y - memory.y) * follow;
          if (typeof memory.r !== "number") {
            memory.r = fittedTarget.r;
          }
          memory.r += (fittedTarget.r - memory.r) * rFollow;

          const fittedMemory = fitDotInsideBlob(
            { x: memory.x, y: memory.y, r: memory.r },
            R,
            isTop,
            padding,
            dividerPoints
          );
          memory.x = fittedMemory.x;
          memory.y = fittedMemory.y;
          memory.r = fittedMemory.r;

          return { x: memory.x, y: memory.y, r: memory.r };
        }

        function geometry() {
          const R = getRadius();
          const padding = DOT_PADDING_CSS * getCanvasScale();
          const globalDeform = getGlobalDeformAmount();
          const dividerPoints = buildDivider(R, globalDeform);
          const lobeCenters = getLobeCenters(R);
          const stackAxisX = dividerXFromPointsAtY(dividerPoints, 0, R);
          const topAuto = findDotAuto(
            R,
            "top",
            padding,
            lobeCenters,
            stackAxisX,
            dividerPoints
          );
          const bottomAuto = findDotAuto(
            R,
            "bottom",
            padding,
            lobeCenters,
            stackAxisX,
            dividerPoints
          );
          const topPlaced = constrainDotToBlob(
            topAuto.x,
            topAuto.y,
            R,
            topAuto.r,
            true,
            padding,
            dividerPoints
          );
          const bottomPlaced = constrainDotToBlob(
            bottomAuto.x,
            bottomAuto.y,
            R,
            bottomAuto.r,
            false,
            padding,
            dividerPoints
          );
          let topTarget = topPlaced
            ? { x: topPlaced.x, y: topPlaced.y, r: topAuto.r }
            : { x: topAuto.x, y: topAuto.y, r: topAuto.r };
          let bottomTarget = bottomPlaced
            ? { x: bottomPlaced.x, y: bottomPlaced.y, r: bottomAuto.r }
            : { x: bottomAuto.x, y: bottomAuto.y, r: bottomAuto.r };

          if (dotUser.top.active) {
            const manualTop = getDotUserPosition("top", R);
            const fittedTop = constrainDotToBlob(
              manualTop.x,
              manualTop.y,
              R,
              Math.max(0.35, R * 0.004),
              true,
              padding,
              dividerPoints
            );
            if (fittedTop) {
              topTarget.x = fittedTop.x;
              topTarget.y = fittedTop.y;
            }
          }

          if (dotUser.bottom.active) {
            const manualBottom = getDotUserPosition("bottom", R);
            const fittedBottom = constrainDotToBlob(
              manualBottom.x,
              manualBottom.y,
              R,
              Math.max(0.35, R * 0.004),
              false,
              padding,
              dividerPoints
            );
            if (fittedBottom) {
              bottomTarget.x = fittedBottom.x;
              bottomTarget.y = fittedBottom.y;
            }
          }

          const stackBias = clamp(0.9 - globalDeform * 0.1, 0.74, 0.9);
          if (!dotUser.top.active) {
            const topStackX = constrainDotXAtY(
              stackAxisX,
              topTarget.y,
              R,
              topTarget.r,
              true,
              padding,
              dividerPoints
            );
            if (topStackX != null) {
              topTarget.x = topTarget.x * (1 - stackBias) + topStackX * stackBias;
            }
          }
          if (!dotUser.bottom.active) {
            const bottomStackX = constrainDotXAtY(
              stackAxisX,
              bottomTarget.y,
              R,
              bottomTarget.r,
              false,
              padding,
              dividerPoints
            );
            if (bottomStackX != null) {
              bottomTarget.x = bottomTarget.x * (1 - stackBias) + bottomStackX * stackBias;
            }
          }

          const pairedStackBias = clamp(0.82 - globalDeform * 0.08, 0.68, 0.82);
          const sharedStackTarget =
            stackAxisX * 0.72 + ((topTarget.x + bottomTarget.x) * 0.5) * 0.28;
          if (!dotUser.top.active) {
            const topSharedX = constrainDotXAtY(
              sharedStackTarget,
              topTarget.y,
              R,
              topTarget.r,
              true,
              padding,
              dividerPoints
            );
            if (topSharedX != null) {
              topTarget.x = topTarget.x * (1 - pairedStackBias) + topSharedX * pairedStackBias;
            }
          }
          if (!dotUser.bottom.active) {
            const bottomSharedX = constrainDotXAtY(
              sharedStackTarget,
              bottomTarget.y,
              R,
              bottomTarget.r,
              false,
              padding,
              dividerPoints
            );
            if (bottomSharedX != null) {
              bottomTarget.x =
                bottomTarget.x * (1 - pairedStackBias) + bottomSharedX * pairedStackBias;
            }
          }

          const topReplaced = constrainDotToBlob(
            topTarget.x,
            topTarget.y,
            R,
            topTarget.r,
            true,
            padding,
            dividerPoints
          );
          if (topReplaced) {
            topTarget.x = topReplaced.x;
            topTarget.y = topReplaced.y;
          }
          const bottomReplaced = constrainDotToBlob(
            bottomTarget.x,
            bottomTarget.y,
            R,
            bottomTarget.r,
            false,
            padding,
            dividerPoints
          );
          if (bottomReplaced) {
            bottomTarget.x = bottomReplaced.x;
            bottomTarget.y = bottomReplaced.y;
          }

          const topRoom = getDotRoomAt(topTarget.x, topTarget.y, R, true, padding, dividerPoints);
          const bottomRoom = getDotRoomAt(
            bottomTarget.x,
            bottomTarget.y,
            R,
            false,
            padding,
            dividerPoints
          );
          const dotLaunchRadius = R * 0.132;
          const launchRoom = Math.max(1e-6, 0.5 * R - padding);
          const topRoomScale = clamp(topRoom / launchRoom, 0.03, 2.5);
          const bottomRoomScale = clamp(bottomRoom / launchRoom, 0.03, 2.5);
          const roomToRadiusScale = (ratio) => Math.pow(ratio, 1.65);
          const topDesiredR = dotLaunchRadius * roomToRadiusScale(topRoomScale);
          const bottomDesiredR = dotLaunchRadius * roomToRadiusScale(bottomRoomScale);
          const topMax = Math.min(topRoom * 0.96, R * 0.38);
          const bottomMax = Math.min(bottomRoom * 0.96, R * 0.38);
          if (topMax > 0) {
            topTarget.r = clamp(topDesiredR, Math.min(R * 0.004, topMax), topMax);
          } else {
            topTarget.r = Math.max(0.35, R * 0.004);
          }
          if (bottomMax > 0) {
            bottomTarget.r = clamp(bottomDesiredR, Math.min(R * 0.004, bottomMax), bottomMax);
          } else {
            bottomTarget.r = Math.max(0.35, R * 0.004);
          }
          topTarget = fitDotInsideBlob(topTarget, R, true, padding, dividerPoints);
          bottomTarget = fitDotInsideBlob(bottomTarget, R, false, padding, dividerPoints);

          if (globalDeform < 0.14) {
            const neutralT = clamp(1 - globalDeform / 0.14, 0, 1);
            const neutralAxisX = dividerXFromPointsAtY(dividerPoints, 0, R);
            const neutralTop = constrainDotToBlob(
              neutralAxisX,
              -0.5 * R,
              R,
              topTarget.r,
              true,
              padding,
              dividerPoints
            );
            const neutralBottom = constrainDotToBlob(
              neutralAxisX,
              0.5 * R,
              R,
              bottomTarget.r,
              false,
              padding,
              dividerPoints
            );
            if (!dotUser.top.active && neutralTop) {
              topTarget.x = topTarget.x * (1 - neutralT) + neutralTop.x * neutralT;
              topTarget.y = topTarget.y * (1 - neutralT) + neutralTop.y * neutralT;
            }
            if (!dotUser.bottom.active && neutralBottom) {
              bottomTarget.x = bottomTarget.x * (1 - neutralT) + neutralBottom.x * neutralT;
              bottomTarget.y = bottomTarget.y * (1 - neutralT) + neutralBottom.y * neutralT;
            }
          }

          if (globalDeform < 0.08) {
            const neutralT = clamp(1 - globalDeform / 0.08, 0, 1);
            const axisX = dividerXFromPointsAtY(dividerPoints, 0, R);
            const topAligned = constrainDotToBlob(
              axisX,
              topTarget.y,
              R,
              topTarget.r,
              true,
              padding,
              dividerPoints
            );
            const bottomAligned = constrainDotToBlob(
              axisX,
              bottomTarget.y,
              R,
              bottomTarget.r,
              false,
              padding,
              dividerPoints
            );

            if (!dotUser.top.active && topAligned) {
              topTarget = {
                x: topTarget.x * (1 - neutralT) + topAligned.x * neutralT,
                y: topTarget.y * (1 - neutralT) + topAligned.y * neutralT,
                r: topTarget.r,
              };
            }
            if (!dotUser.bottom.active && bottomAligned) {
              bottomTarget = {
                x: bottomTarget.x * (1 - neutralT) + bottomAligned.x * neutralT,
                y: bottomTarget.y * (1 - neutralT) + bottomAligned.y * neutralT,
                r: bottomTarget.r,
              };
            }
          }

          const topDot = stabilizeDotCenter(topTarget, "top", R, true, padding, dividerPoints);
          const bottomDot = stabilizeDotCenter(
            bottomTarget,
            "bottom",
            R,
            false,
            padding,
            dividerPoints
          );

          if (dotUser.top.active) {
            setDotUserPosition("top", topDot.x, topDot.y, R);
          }
          if (dotUser.bottom.active) {
            setDotUserPosition("bottom", bottomDot.x, bottomDot.y, R);
          }

          return { R, dividerPoints, topDot, bottomDot, padding };
        }

        function drawCircle(cx, cy, r) {
          if (r <= 0) return;
          ctx.beginPath();
          ctx.arc(cx, cy, r, 0, TAU);
          ctx.fill();
        }

        function isInsideHost(x, y, R, isTop, dividerPoints) {
          if (!isInsideCircle(x, y, R)) return false;
          const white = isWhiteAt(x, y, R, dividerPoints);
          return isTop ? white : !white;
        }

        function rayBoundaryDistance(cx, cy, dirX, dirY, R, isTop, dividerPoints) {
          const cDot = cx * dirX + cy * dirY;
          const cSq = cx * cx + cy * cy;
          const disc = cDot * cDot + (R * R - cSq);
          if (disc <= 0) return 0;
          const outerT = -cDot + Math.sqrt(disc);
          let lo = 0;
          let hi = Math.max(1e-4, outerT + 1);

          for (let i = 0; i < 14; i += 1) {
            const mid = (lo + hi) * 0.5;
            const px = cx + dirX * mid;
            const py = cy + dirY * mid;
            if (isInsideHost(px, py, R, isTop, dividerPoints)) {
              lo = mid;
            } else {
              hi = mid;
            }
          }
          return lo;
        }

        function getDotBlobPoints(dot, R, isTop, padding, dividerPoints) {
          const samples = 34;
          const avails = new Array(samples);
          let minAvail = Infinity;
          let maxAvail = 0;
          const baseRadius = Math.max(0.35, dot.r);

          for (let i = 0; i < samples; i += 1) {
            const angle = (i / samples) * TAU;
            const dirX = Math.cos(angle);
            const dirY = Math.sin(angle);
            const boundaryDist = rayBoundaryDistance(
              dot.x,
              dot.y,
              dirX,
              dirY,
              R,
              isTop,
              dividerPoints
            );
            const avail = Math.max(0.35, boundaryDist - padding);
            avails[i] = avail;
            minAvail = Math.min(minAvail, avail);
            maxAvail = Math.max(maxAvail, avail);
          }

          const avgAvail = avails.reduce((sum, value) => sum + value, 0) / samples;
          const hostAnisotropy = clamp(
            (maxAvail - minAvail) / Math.max(1e-6, avgAvail),
            0,
            1
          );
          const squeeze = clamp((baseRadius - minAvail) / Math.max(1e-6, baseRadius), 0, 1);
          const globalDeform = getGlobalDeformAmount();
          const deformGate = clamp((globalDeform - 0.02) / 0.2, 0, 1);
          const shapeBlend = clamp(
            (0.075 + 0.54 * hostAnisotropy + 0.31 * squeeze) * deformGate,
            0,
            0.82
          );

          const minRadius = Math.max(
            0.28,
            baseRadius * (1 - (0.48 * squeeze + 0.18 * hostAnisotropy) * deformGate)
          );
          const expandCap = baseRadius * (1 + 0.055 + 0.12 * shapeBlend);

          let radii = avails.map((avail) => {
            const localFactor = clamp(avail / Math.max(1e-6, avgAvail), 0.78, 1.24);
            const profileMatch =
              baseRadius * (1 + (localFactor - 1) * (shapeBlend * 0.64));
            const wallFollow = baseRadius + (avail - baseRadius) * (0.14 * shapeBlend);
            const radius = baseRadius * 0.24 + profileMatch * 0.54 + wallFollow * 0.22;
            return clamp(radius, minRadius, Math.min(avail, expandCap));
          });

          for (let pass = 0; pass < 3; pass += 1) {
            const smoothed = new Array(samples);
            for (let i = 0; i < samples; i += 1) {
              const prev = radii[(i - 1 + samples) % samples];
              const curr = radii[i];
              const next = radii[(i + 1) % samples];
              smoothed[i] = clamp((prev + curr * 2 + next) * 0.25, minRadius, avails[i]);
            }
            radii = smoothed;
          }

          const points = new Array(samples);
          for (let i = 0; i < samples; i += 1) {
            const angle = (i / samples) * TAU;
            const radius = radii[i];
            points[i] = {
              x: dot.x + Math.cos(angle) * radius,
              y: dot.y + Math.sin(angle) * radius,
            };
          }
          let minRadiusFinal = Infinity;
          let maxRadiusFinal = 0;
          for (let i = 0; i < samples; i += 1) {
            minRadiusFinal = Math.min(minRadiusFinal, radii[i]);
            maxRadiusFinal = Math.max(maxRadiusFinal, radii[i]);
          }
          const anisotropy = clamp(
            (maxRadiusFinal - minRadiusFinal) / Math.max(1e-6, baseRadius),
            0,
            1
          );
          return { points, anisotropy, squeeze, deformGate };
        }

        function drawDeformedDot(dot, R, isTop, padding, dividerPoints) {
          if (dot.r <= 0) return;
          if (!isInsideHost(dot.x, dot.y, R, isTop, dividerPoints)) {
            return;
          }
          const profile = getDotBlobPoints(dot, R, isTop, padding, dividerPoints);
          if (
            !profile ||
            profile.points.length < 3 ||
            (profile.deformGate < 0.03 ||
              (profile.squeeze < 0.008 && profile.anisotropy < 0.025) ||
              profile.anisotropy < 0.006 ||
              profile.squeeze > 0.62 ||
              profile.anisotropy > 0.62)
          ) {
            drawCircle(dot.x, dot.y, dot.r);
            return;
          }

          const points = profile.points;
          const n = points.length;
          const startMid = {
            x: (points[n - 1].x + points[0].x) * 0.5,
            y: (points[n - 1].y + points[0].y) * 0.5,
          };

          ctx.beginPath();
          ctx.moveTo(startMid.x, startMid.y);
          for (let i = 0; i < n; i += 1) {
            const curr = points[i];
            const next = points[(i + 1) % n];
            const mid = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };
            ctx.quadraticCurveTo(curr.x, curr.y, mid.x, mid.y);
          }
          ctx.closePath();
          ctx.fill();
        }

        function appendSmoothDivider(points) {
          if (points.length < 2) return;
          ctx.moveTo(points[0].x, points[0].y);
          for (let i = 1; i < points.length - 1; i += 1) {
            const curr = points[i];
            const next = points[i + 1];
            const midX = (curr.x + next.x) * 0.5;
            const midY = (curr.y + next.y) * 0.5;
            ctx.quadraticCurveTo(curr.x, curr.y, midX, midY);
          }
          const last = points[points.length - 1];
          ctx.lineTo(last.x, last.y);
        }

        function traceSmoothDivider(points) {
          if (points.length < 2) return;
          ctx.beginPath();
          appendSmoothDivider(points);
        }

        function appendBlackRegionPath(points, R) {
          appendSmoothDivider(points);
          const arcSteps = 260;
          for (let i = 0; i <= arcSteps; i += 1) {
            const t = i / arcSteps;
            const theta = Math.PI * 0.5 - Math.PI * t;
            ctx.lineTo(R * Math.cos(theta), R * Math.sin(theta));
          }
          ctx.closePath();
        }

        function traceBlackRegionPath(points, R) {
          ctx.beginPath();
          appendBlackRegionPath(points, R);
        }

        function strokeDotOutline(dot, R, isTop, padding, dividerPoints) {
          if (!isInsideHost(dot.x, dot.y, R, isTop, dividerPoints)) return;
          const profile = getDotBlobPoints(dot, R, isTop, padding, dividerPoints);
          if (
            !profile ||
            profile.points.length < 3 ||
            (profile.deformGate < 0.03 ||
              (profile.squeeze < 0.008 && profile.anisotropy < 0.025) ||
              profile.anisotropy < 0.006 ||
              profile.squeeze > 0.62 ||
              profile.anisotropy > 0.62)
          ) {
            ctx.beginPath();
            ctx.arc(dot.x, dot.y, dot.r, 0, TAU);
            ctx.stroke();
            return;
          }

          const points = profile.points;
          const n = points.length;
          const startMid = {
            x: (points[n - 1].x + points[0].x) * 0.5,
            y: (points[n - 1].y + points[0].y) * 0.5,
          };
          ctx.beginPath();
          ctx.moveTo(startMid.x, startMid.y);
          for (let i = 0; i < n; i += 1) {
            const curr = points[i];
            const next = points[(i + 1) % n];
            const mid = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };
            ctx.quadraticCurveTo(curr.x, curr.y, mid.x, mid.y);
          }
          ctx.closePath();
          ctx.stroke();
        }

        function drawSelectionRing(mode, geometryState) {
          if (!mode) return;
          const ringWidth = SELECTION_RING_WIDTH_CSS * getCanvasScale();
          ctx.save();
          ctx.translate(canvas.width / 2, canvas.height / 2);
          ctx.lineWidth = ringWidth * 1.15;
          ctx.lineJoin = "round";
          ctx.lineCap = "round";
          ctx.strokeStyle = "rgba(255, 38, 38, 0.95)";

          if (mode === "topDotMove") {
            strokeDotOutline(
              geometryState.topDot,
              geometryState.R,
              true,
              geometryState.padding,
              geometryState.dividerPoints
            );
            ctx.restore();
            return;
          }
          if (mode === "bottomDotMove") {
            strokeDotOutline(
              geometryState.bottomDot,
              geometryState.R,
              false,
              geometryState.padding,
              geometryState.dividerPoints
            );
            ctx.restore();
            return;
          }

          const highlightWhite = mode === "white";
          if (!highlightWhite && mode !== "black") {
            ctx.restore();
            return;
          }

          ctx.save();
          if (highlightWhite) {
            ctx.lineWidth = ringWidth * 2.1;
            ctx.beginPath();
            ctx.arc(0, 0, geometryState.R, 0, TAU);
            appendBlackRegionPath(geometryState.dividerPoints, geometryState.R);
            ctx.clip("evenodd");
          } else {
            ctx.lineWidth = ringWidth * 2.1;
            traceBlackRegionPath(geometryState.dividerPoints, geometryState.R);
            ctx.clip();
          }

          ctx.beginPath();
          ctx.arc(0, 0, geometryState.R, 0, TAU);
          ctx.stroke();
          traceSmoothDivider(geometryState.dividerPoints);
          ctx.stroke();
          ctx.restore();
          ctx.restore();
        }

        function draw() {
          resizeCanvasToDisplaySize();
          const stillEasing = easeStateTowardTarget();
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const w = canvas.width;
          const h = canvas.height;
          const cx = w / 2;
          const cy = h / 2;
          const g = geometry();
          const lineWidth = Math.max(2, g.R * 0.02);

          ctx.save();
          ctx.shadowColor = "rgba(0,0,0,0.28)";
          ctx.shadowBlur = Math.max(10, g.R * 0.08);
          ctx.shadowOffsetY = Math.max(6, g.R * 0.03);
          ctx.beginPath();
          ctx.arc(cx, cy, g.R, 0, TAU);
          ctx.fillStyle = "rgba(0,0,0,0)";
          ctx.fill();
          ctx.restore();

          ctx.save();
          ctx.translate(cx, cy);
          ctx.beginPath();
          ctx.arc(0, 0, g.R, 0, TAU);
          ctx.clip();

          ctx.fillStyle = COLORS.white;
          ctx.beginPath();
          ctx.arc(0, 0, g.R, 0, TAU);
          ctx.fill();

          ctx.fillStyle = COLORS.black;
          traceBlackRegionPath(g.dividerPoints, g.R);
          ctx.fill();

          ctx.fillStyle = COLORS.black;
          ctx.save();
          ctx.beginPath();
          ctx.arc(0, 0, g.R, 0, TAU);
          appendBlackRegionPath(g.dividerPoints, g.R);
          ctx.clip("evenodd");
          drawDeformedDot(g.topDot, g.R, true, g.padding, g.dividerPoints);
          ctx.restore();

          ctx.fillStyle = COLORS.white;
          ctx.save();
          traceBlackRegionPath(g.dividerPoints, g.R);
          ctx.clip();
          drawDeformedDot(g.bottomDot, g.R, false, g.padding, g.dividerPoints);
          ctx.restore();

          ctx.restore();

          ctx.beginPath();
          ctx.arc(cx, cy, g.R, 0, TAU);
          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = "rgba(0,0,0,0.75)";
          ctx.stroke();

          if (drag.active) {
            drawSelectionRing(drag.mode, g);
          }

          if (stillEasing) {
            requestDraw();
          }
        }

        function buildSnapshotCanvas(size = 1800) {
          draw();
          renderDateStamps();
          const snapshot = document.createElement("canvas");
          snapshot.width = size;
          snapshot.height = size;
          const snapshotCtx = snapshot.getContext("2d", { alpha: false });
          const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#a87444";
          snapshotCtx.fillStyle = bgColor;
          snapshotCtx.fillRect(0, 0, size, size);

          const symbolFrame = size * 0.8;
          const symbolX = (size - symbolFrame) * 0.5;
          const symbolY = (size - symbolFrame) * 0.5;
          snapshotCtx.drawImage(canvas, symbolX, symbolY, symbolFrame, symbolFrame);

          const stamp = formatDisplayDate(new Date());
          const fontSize = Math.round(size * 0.05);
          const edgePadX = size * 0.055;
          const topPadY = size * 0.045;
          const bottomAnchorY = size * 0.965;
          snapshotCtx.font = `700 ${fontSize}px ${CONDENSED_FONT_STACK}`;
          snapshotCtx.textBaseline = "top";
          snapshotCtx.textAlign = "right";
          snapshotCtx.fillStyle = "rgba(246, 241, 230, 0.96)";
          snapshotCtx.fillText(stamp, size - edgePadX, topPadY);

          snapshotCtx.save();
          const stampWidth = snapshotCtx.measureText(stamp).width;
          snapshotCtx.translate(edgePadX + stampWidth, bottomAnchorY);
          snapshotCtx.rotate(Math.PI);
          snapshotCtx.textBaseline = "top";
          snapshotCtx.textAlign = "left";
          snapshotCtx.fillStyle = "rgba(17, 17, 17, 0.94)";
          snapshotCtx.fillText(stamp, 0, 0);
          snapshotCtx.restore();

          return snapshot;
        }

        function canvasToBlob(canvasNode) {
          return new Promise((resolve, reject) => {
            if (typeof canvasNode.toBlob !== "function") {
              try {
                const dataUrl = canvasNode.toDataURL("image/png");
                fetch(dataUrl)
                  .then((response) => response.blob())
                  .then(resolve)
                  .catch(reject);
                return;
              } catch (error) {
                reject(error);
                return;
              }
            }
            canvasNode.toBlob((blob) => {
              if (!blob) {
                reject(new Error("Could not create image blob"));
                return;
              }
              resolve(blob);
            }, "image/png");
          });
        }

        function downloadBlob(blob, fileName) {
          const url = URL.createObjectURL(blob);
          const link = document.createElement("a");
          link.href = url;
          link.download = fileName;
          document.body.append(link);
          link.click();
          link.remove();
          setTimeout(() => URL.revokeObjectURL(url), 1500);
        }

        async function shareSnapshot(blob, fileName) {
          if (!("share" in navigator)) return false;
          if (typeof File !== "function") return false;
          const file = new File([blob], fileName, { type: "image/png" });
          if ("canShare" in navigator && !navigator.canShare({ files: [file] })) return false;
          await navigator.share({
            title: "Mood snapshot",
            files: [file],
          });
          return true;
        }

        function openBlobInNewTab(blob) {
          const url = URL.createObjectURL(blob);
          const opened = window.open(url, "_blank", "noopener,noreferrer");
          setTimeout(() => URL.revokeObjectURL(url), 6000);
          return Boolean(opened);
        }

        async function captureMoodSymbol() {
          if (saveState.isSaving) return;
          saveState.isSaving = true;
          saveShotButton.disabled = true;
          saveShotButton.classList.add("is-saving");
          setSaveStatus("Saving...");

          try {
            const now = new Date();
            const fileStamp = formatFilenameStamp(now);
            const fileName = `Mood - ${fileStamp.date} - ${fileStamp.time}.png`;
            const snapshotCanvas = buildSnapshotCanvas();
            const blob = await canvasToBlob(snapshotCanvas);

            if (isIOSLike) {
              try {
                const shared = await shareSnapshot(blob, fileName);
                if (shared) {
                  setSaveStatus("Shared mood snapshot");
                  return;
                }
              } catch (error) {
                if (error?.name === "AbortError") {
                  setSaveStatus("Share canceled");
                  return;
                }
              }

              const opened = openBlobInNewTab(blob);
              if (opened) {
                setSaveStatus("Opened snapshot tab");
                return;
              }
            }

            downloadBlob(blob, fileName);
            setSaveStatus("Saved mood snapshot");
          } catch (error) {
            setSaveStatus("Couldnt save snapshot");
          } finally {
            saveShotButton.disabled = false;
            saveShotButton.classList.remove("is-saving");
            saveState.isSaving = false;
          }
        }

        function requestDraw() {
          if (requestDraw._raf) return;
          requestDraw._raf = requestAnimationFrame(() => {
            requestDraw._raf = 0;
            draw();
          });
        }

        canvas.addEventListener("pointerdown", (e) => {
          resizeCanvasToDisplaySize();
          const local = getLocalPoint(e);
          const g = geometry();
          if (!isInsideCircle(local.x, local.y, g.R)) return;

          drag.active = true;
          drag.pointerId = e.pointerId;
          drag.start = local;
          drag.last = local;
          drag.startWhitePush = stateTarget.whitePush;
          drag.startBlackPush = stateTarget.blackPush;
          drag.startWhiteLift = stateTarget.whiteLift;
          drag.startBlackLift = stateTarget.blackLift;
          drag.startWhiteLocalShiftX = stateTarget.whiteLocalShiftX;
          drag.startBlackLocalShiftX = stateTarget.blackLocalShiftX;
          drag.startWhiteFocusY = stateTarget.whiteFocusY;
          drag.startBlackFocusY = stateTarget.blackFocusY;
          drag.grabYNorm = clamp(local.y / g.R, -1, 1);
          const influence = getGrabInfluence(drag.grabYNorm);
          drag.topInfluence = influence.top;
          drag.bottomInfluence = influence.bottom;
          drag.activeDotCenter = { x: 0, y: 0 };
          drag.activeDotOffset = { x: 0, y: 0 };

          const hitPad = DOT_DRAG_HIT_PAD_CSS * getCanvasScale();
          const topDist = Math.hypot(local.x - g.topDot.x, local.y - g.topDot.y);
          const bottomDist = Math.hypot(local.x - g.bottomDot.x, local.y - g.bottomDot.y);
          const topHitR = g.topDot.r + hitPad;
          const bottomHitR = g.bottomDot.r + hitPad;
          const insideTopDot = topDist <= topHitR;
          const insideBottomDot = bottomDist <= bottomHitR;

          if (insideTopDot || insideBottomDot) {
            let selected = "top";
            if (!insideTopDot) {
              selected = "bottom";
            } else if (insideBottomDot) {
              const topNorm = topDist / Math.max(1e-6, topHitR);
              const bottomNorm = bottomDist / Math.max(1e-6, bottomHitR);
              selected = topNorm <= bottomNorm ? "top" : "bottom";
            }
            drag.mode = selected === "top" ? "topDotMove" : "bottomDotMove";
            drag.activeDotCenter =
              selected === "top" ? { x: g.topDot.x, y: g.topDot.y } : { x: g.bottomDot.x, y: g.bottomDot.y };
            drag.activeDotOffset = {
              x: local.x - drag.activeDotCenter.x,
              y: local.y - drag.activeDotCenter.y,
            };
            setDotUserPosition(
              selected,
              drag.activeDotCenter.x,
              drag.activeDotCenter.y,
              g.R
            );
          } else {
            drag.mode = isWhiteAt(local.x, local.y, g.R, g.dividerPoints) ? "white" : "black";
          }

          if (drag.mode === "white") {
            stateTarget.whiteFocusY = drag.grabYNorm;
            drag.startWhiteFocusY = stateTarget.whiteFocusY;
          } else if (drag.mode === "black") {
            stateTarget.blackFocusY = drag.grabYNorm;
            drag.startBlackFocusY = stateTarget.blackFocusY;
          }

          canvas.setPointerCapture(e.pointerId);
          requestDraw();
        });

        canvas.addEventListener("pointermove", (e) => {
          if (!drag.active || e.pointerId !== drag.pointerId) return;
          resizeCanvasToDisplaySize();
          const local = getLocalPoint(e);
          const R = getRadius();
          const dx = local.x - drag.start.x;
          const dy = local.y - drag.start.y;

          if (drag.mode === "white" || drag.mode === "black") {
            const localHorizontal = dx / (0.82 * R);
            const localVertical = dy / (0.58 * R);
            const globalHorizontal = dx / (1.46 * R);
            const globalVertical = dy / (0.64 * R);
            const verticalRatioDrive = globalVertical * 0.2;

            if (drag.mode === "white") {
              const topGain = 0.3 + 1.02 * drag.topInfluence;
              const bottomGain = 0.14 + 0.28 * drag.bottomInfluence;

              stateTarget.whiteLocalShiftX = clamp(
                drag.startWhiteLocalShiftX + localHorizontal * 0.92,
                -1.35,
                1.35
              );
              stateTarget.whiteFocusY = clamp(drag.startWhiteFocusY + localVertical * 1.18, -1.08, 1.08);
              stateTarget.whitePush = clampPush(
                drag.startWhitePush + globalHorizontal * topGain + verticalRatioDrive * 0.62
              );
              stateTarget.blackPush = clampPush(
                drag.startBlackPush -
                  globalHorizontal * bottomGain * 0.42 -
                  verticalRatioDrive * 0.58
              );
              stateTarget.whiteLift = clamp(
                drag.startWhiteLift + globalVertical * (1.14 + 0.58 * drag.topInfluence),
                -1.45,
                1.45
              );
              stateTarget.blackLift = clamp(
                drag.startBlackLift + globalVertical * (0.05 + 0.11 * drag.bottomInfluence),
                -1.45,
                1.45
              );
            } else {
              const bottomGain = 0.3 + 1.02 * drag.bottomInfluence;
              const topGain = 0.14 + 0.28 * drag.topInfluence;

              stateTarget.blackLocalShiftX = clamp(
                drag.startBlackLocalShiftX - localHorizontal * 0.92,
                -1.35,
                1.35
              );
              stateTarget.blackFocusY = clamp(drag.startBlackFocusY + localVertical * 1.18, -1.08, 1.08);
              stateTarget.blackPush = clampPush(
                drag.startBlackPush - globalHorizontal * bottomGain + verticalRatioDrive * 0.62
              );
              stateTarget.whitePush = clampPush(
                drag.startWhitePush + globalHorizontal * topGain * 0.42 + verticalRatioDrive * 0.58
              );
              stateTarget.blackLift = clamp(
                drag.startBlackLift + globalVertical * (1.14 + 0.58 * drag.bottomInfluence),
                -1.45,
                1.45
              );
              stateTarget.whiteLift = clamp(
                drag.startWhiteLift + globalVertical * (0.05 + 0.11 * drag.topInfluence),
                -1.45,
                1.45
              );
            }
            drag.last = local;
          } else if (drag.mode === "topDotMove" || drag.mode === "bottomDotMove") {
            const key = drag.mode === "topDotMove" ? "top" : "bottom";
            const desiredX = local.x - drag.activeDotOffset.x;
            const desiredY = local.y - drag.activeDotOffset.y;
            setDotUserPosition(key, desiredX, desiredY, R);
          }

          requestDraw();
        });

        function endDrag(e) {
          if (!drag.active) return;
          if (e && typeof e.pointerId === "number" && e.pointerId !== drag.pointerId) return;
          drag.active = false;
          if (
            drag.pointerId != null &&
            typeof canvas.hasPointerCapture === "function" &&
            canvas.hasPointerCapture(drag.pointerId)
          ) {
            try {
              canvas.releasePointerCapture(drag.pointerId);
            } catch (_) {}
          }
          drag.pointerId = null;
          drag.mode = null;
          requestDraw();
        }

        canvas.addEventListener("pointerup", endDrag);
        canvas.addEventListener("pointercancel", endDrag);
        canvas.addEventListener("lostpointercapture", () => endDrag());
        window.addEventListener("blur", () => endDrag());
        window.addEventListener("resize", requestDraw, { passive: true });
        saveShotButton.addEventListener("click", captureMoodSymbol);
        window.addEventListener("keydown", (event) => {
          if (event.code !== "Space" || event.repeat) return;
          const activeTag = (document.activeElement?.tagName || "").toLowerCase();
          if (activeTag === "input" || activeTag === "textarea" || activeTag === "select") return;
          event.preventDefault();
          captureMoodSymbol();
        });

        requestDraw();
      })();
    </script>
  </body>
</html>
