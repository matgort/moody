
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Yin Yang Moods</title>
    <style>
      :root {
        --bg: #a87444;
        --black: #111111;
        --white: #f6f1e6;
      }

      html,
      body {
        height: 100%;
      }

      body {
        margin: 0;
        background: var(--bg);
        display: grid;
        place-items: center;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      }

      .wrap {
        width: min(86vmin, 640px);
        aspect-ratio: 1;
        display: grid;
        place-items: center;
      }

      canvas {
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
      }

      .hint {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 14px;
        padding: 0 16px;
        text-align: center;
        font-size: 12px;
        color: rgba(0, 0, 0, 0.55);
        user-select: none;
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <main class="wrap">
      <canvas id="yy" aria-label="Interactive yin yang mood tracker"></canvas>
    </main>
    <div class="hint">Drag white/black lobes to reshape. Drag inside dots to resize.</div>

    <script>
      (() => {
        const TAU = Math.PI * 2;
        const canvas = document.getElementById("yy");
        const ctx = canvas.getContext("2d", { alpha: true });

        const COLORS = {
          black: getComputedStyle(document.documentElement).getPropertyValue("--black").trim(),
          white: getComputedStyle(document.documentElement).getPropertyValue("--white").trim(),
        };
        const DOT_PADDING_CSS = 5;
        const DOT_HIT_PAD_CSS = 26;
        const DOT_RESIZE_INNER_PAD_CSS = 4;

        const state = {
          whitePush: 0.5,
          blackPush: 0.5,
          whiteLift: 0,
          blackLift: 0,
          topDotScale: 0.5,
          bottomDotScale: 0.5,
        };

        const drag = {
          active: false,
          pointerId: null,
          mode: null, // "white" | "black" | "topDotResize" | "bottomDotResize"
          start: { x: 0, y: 0 },
          startWhitePush: 0.5,
          startBlackPush: 0.5,
          startWhiteLift: 0,
          startBlackLift: 0,
          startTopScale: 0.5,
          startBottomScale: 0.5,
          grabYNorm: 0,
          topInfluence: 0.5,
          bottomInfluence: 0.5,
          activeDotCenter: { x: 0, y: 0 },
          activeDotStartDist: 0,
        };

        const dotMemory = {
          top: null,
          bottom: null,
        };

        function clamp(n, min, max) {
          return Math.min(max, Math.max(min, n));
        }

        function getGrabInfluence(yNorm) {
          const yn = clamp(yNorm, -1, 1);
          const sigma = 0.46;
          const topRaw = Math.exp(-Math.pow((yn + 0.52) / sigma, 2));
          const bottomRaw = Math.exp(-Math.pow((yn - 0.52) / sigma, 2));
          const sum = topRaw + bottomRaw + 1e-9;
          return { top: topRaw / sum, bottom: bottomRaw / sum };
        }

        function resizeCanvasToDisplaySize() {
          const rect = canvas.getBoundingClientRect();
          const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
          const w = Math.max(2, Math.round(rect.width * dpr));
          const h = Math.max(2, Math.round(rect.height * dpr));
          if (canvas.width !== w || canvas.height !== h) {
            canvas.width = w;
            canvas.height = h;
          }
        }

        function getLocalPoint(e) {
          const rect = canvas.getBoundingClientRect();
          const sx = canvas.width / rect.width;
          const sy = canvas.height / rect.height;
          const x = (e.clientX - rect.left) * sx;
          const y = (e.clientY - rect.top) * sy;
          return { x: x - canvas.width / 2, y: y - canvas.height / 2 };
        }

        function getRadius() {
          return Math.min(canvas.width, canvas.height) * 0.44;
        }

        function getCanvasScale() {
          return canvas.width / Math.max(1, canvas.clientWidth || 1);
        }

        function isInsideCircle(x, y, R) {
          return x * x + y * y <= R * R;
        }

        function getLobeCoefficients() {
          const whiteDelta = (state.whitePush - 0.5) * 2;
          const blackDelta = (state.blackPush - 0.5) * 2;
          const topDrive = 1.36 * whiteDelta - 0.66 * blackDelta;
          const bottomDrive = 1.36 * blackDelta - 0.66 * whiteDelta;
          const topCoeff = clamp(0.5 * Math.exp(topDrive), 0.12, 1.45);
          const bottomCoeff = clamp(0.5 * Math.exp(bottomDrive), 0.12, 1.45);
          return { whiteDelta, blackDelta, topCoeff, bottomCoeff };
        }

        function getLobeCenters(R) {
          const half = R * 0.5;
          let topCenter = -half + state.whiteLift * 0.34 * R;
          let bottomCenter = half + state.blackLift * 0.34 * R;

          topCenter = clamp(topCenter, -0.82 * R, -0.12 * R);
          bottomCenter = clamp(bottomCenter, 0.12 * R, 0.82 * R);

          const minGap = 0.36 * R;
          const maxGap = 1.06 * R;
          let gap = bottomCenter - topCenter;
          if (gap < minGap) {
            const spread = (minGap - gap) * 0.5;
            topCenter -= spread;
            bottomCenter += spread;
          } else if (gap > maxGap) {
            const compress = (gap - maxGap) * 0.5;
            topCenter += compress;
            bottomCenter -= compress;
          }
          gap = bottomCenter - topCenter;
          if (gap < minGap) {
            const mid = (topCenter + bottomCenter) * 0.5;
            topCenter = mid - minGap * 0.5;
            bottomCenter = mid + minGap * 0.5;
          }

          return { topCenter, bottomCenter };
        }

        function baseDividerX(y, R) {
          const half = R * 0.5;
          if (y <= 0) {
            const dy = y + half;
            return Math.sqrt(Math.max(0, half * half - dy * dy));
          }
          const dy = y - half;
          return -Math.sqrt(Math.max(0, half * half - dy * dy));
        }

        function dividerXAtY(y, R) {
          const t = y / R;
          const { whiteDelta, blackDelta, topCoeff, bottomCoeff } = getLobeCoefficients();
          const { topCenter, bottomCenter } = getLobeCenters(R);
          const dominance = clamp(state.whitePush - state.blackPush, -1, 1);
          const dominanceAbs = Math.abs(dominance);
          const outerX = Math.sqrt(Math.max(0, R * R - y * y));

          const base = baseDividerX(y, R);
          const sigma = 0.35 * R;
          const topProfile = Math.exp(-Math.pow((y - topCenter) / sigma, 2));
          const bottomProfile = Math.exp(-Math.pow((y - bottomCenter) / sigma, 2));
          const middleProfile = Math.exp(-Math.pow(y / (0.52 * R), 2));
          const envelope = Math.pow(Math.max(0, 1 - t * t), 1.35);
          const edgeEnvelope = 0.25 + 0.75 * envelope;
          const dominanceBoost = 1 + 3.5 * Math.pow(dominanceAbs, 2.5);

          const topDrive = topCoeff - 0.5;
          const bottomDrive = bottomCoeff - 0.5;
          let deform =
            0.82 * topDrive * topProfile -
            0.82 * bottomDrive * bottomProfile +
            0.24 * (topDrive - bottomDrive) * middleProfile +
            0.18 * state.whiteLift * topProfile -
            0.18 * state.blackLift * bottomProfile +
            0.1 * (state.whiteLift - state.blackLift) * t;
          deform *= envelope * R;

          let x = base + deform;
          const dominanceShift =
            dominance * outerX * (0.72 + 0.12 * middleProfile) * edgeEnvelope * dominanceBoost;
          x += dominanceShift;

          const limit = outerX * 0.9992;
          if (limit <= 1e-9) return 0;
          x = limit * Math.tanh(x / (limit + 1e-9));
          return x;
        }

        function getDotScaleBias(areaFractions) {
          const { topCoeff, bottomCoeff } = getLobeCoefficients();
          const whiteFrac = clamp(areaFractions?.white ?? 0.5, 0.01, 0.99);
          const blackFrac = clamp(areaFractions?.black ?? 0.5, 0.01, 0.99);

          const areaToBias = (fraction) => clamp(Math.pow(fraction / 0.5, 1.35), 0.06, 1.22);
          const shapeToBias = (coeff) => clamp(Math.pow(coeff / 0.5, 0.28), 0.82, 1.16);

          const topAreaBias = areaToBias(whiteFrac);
          const bottomAreaBias = areaToBias(blackFrac);
          const topShapeBias = shapeToBias(topCoeff);
          const bottomShapeBias = shapeToBias(bottomCoeff);

          return {
            top: clamp(topAreaBias * 0.88 + topShapeBias * 0.12, 0.06, 1.22),
            bottom: clamp(bottomAreaBias * 0.88 + bottomShapeBias * 0.12, 0.06, 1.22),
          };
        }

        function getGlobalDeformAmount() {
          const pushDelta =
            Math.max(Math.abs(state.whitePush - 0.5), Math.abs(state.blackPush - 0.5)) * 2;
          const liftDelta = Math.max(Math.abs(state.whiteLift), Math.abs(state.blackLift));
          return clamp(Math.max(pushDelta, liftDelta), 0, 1);
        }

        function buildDivider(R, steps = 720) {
          const points = [];
          for (let i = 0; i <= steps; i += 1) {
            const y = -R + (2 * R * i) / steps;
            points.push({ x: dividerXAtY(y, R), y });
          }
          return points;
        }

        function estimateColorFractions(R, dividerPoints) {
          const steps = Math.max(1, dividerPoints.length - 1);
          const dy = (2 * R) / steps;
          let whiteArea = 0;

          for (let i = 0; i < dividerPoints.length; i += 1) {
            const y = dividerPoints[i].y;
            const outerX = Math.sqrt(Math.max(0, R * R - y * y));
            const dividerX = clamp(dividerPoints[i].x, -outerX, outerX);
            const whiteSpan = clamp(dividerX + outerX, 0, 2 * outerX);
            whiteArea += whiteSpan * dy;
          }

          const totalArea = Math.PI * R * R;
          const white = clamp(whiteArea / Math.max(1e-6, totalArea), 0, 1);
          return { white, black: 1 - white };
        }

        function isWhiteAt(x, y, R) {
          return x <= dividerXAtY(y, R);
        }

        function findDotAuto(R, region, scaleFactor, padding, lobeCenters) {
          const isTop = region === "top";
          const dominance = clamp(state.whitePush - state.blackPush, -1, 1);
          const yAnchor = isTop ? lobeCenters.topCenter - 0.08 * R : lobeCenters.bottomCenter + 0.08 * R;
          const dividerAtAnchor = dividerXAtY(yAnchor, R);
          const xAnchor =
            dividerAtAnchor +
            (isTop ? -0.04 : 0.04) * R +
            dominance * (isTop ? 0.16 : -0.16) * R;
          const spanX = 0.74 * R;
          const spanY = 0.54 * R;
          const cols = 46;
          const rows = 46;

          let best = null;
          const pool = [];

          for (let iy = 0; iy <= rows; iy += 1) {
            const y = yAnchor - spanY * 0.5 + (spanY * iy) / rows;
            const outer = Math.sqrt(Math.max(0, R * R - y * y));
            for (let ix = 0; ix <= cols; ix += 1) {
              const x = xAnchor - spanX * 0.5 + (spanX * ix) / cols;
              if (Math.abs(x) >= outer) continue;

              const white = isWhiteAt(x, y, R);
              if ((isTop && !white) || (!isTop && white)) continue;

              const dOuter = R - Math.hypot(x, y);
              const dDivider = Math.abs(x - dividerXAtY(y, R));
              const maxR = Math.min(dOuter, dDivider) - padding;
              if (maxR <= 0) continue;

              const roomN = maxR / R;
              const depthN = dDivider / R;
              const verticalN = 1 - clamp(Math.abs(y - yAnchor) / (0.48 * R), 0, 1);
              const anchorN = 1 - clamp(Math.hypot((x - xAnchor) / spanX, (y - yAnchor) / spanY), 0, 1);
              const score = 1.45 * roomN + 0.22 * depthN + 0.2 * verticalN + 0.08 * anchorN;
              const candidate = { x, y, maxR, score };
              pool.push(candidate);

              if (!best || score > best.score) {
                best = candidate;
              }
            }
          }

          if (!best) {
            return { x: xAnchor, y: yAnchor, r: R * 0.08, room: R * 0.08 };
          }

          let chosen = best;
          if (pool.length > 1) {
            const cutoff = best.score - 0.12;
            let wSum = 0;
            let xSum = 0;
            let ySum = 0;
            let roomSum = 0;
            for (let i = 0; i < pool.length; i += 1) {
              const candidate = pool[i];
              if (candidate.score < cutoff) continue;
              const weight = Math.exp((candidate.score - best.score) * 10);
              wSum += weight;
              xSum += candidate.x * weight;
              ySum += candidate.y * weight;
              roomSum += candidate.maxR * weight;
            }
            if (wSum > 1e-6) {
              chosen = {
                x: xSum / wSum,
                y: ySum / wSum,
                maxR: roomSum / wSum,
                score: best.score,
              };
            }
          }

          const maxAllowed = Math.min(chosen.maxR * 0.56, R * 0.21);
          const minAllowed = Math.min(R * 0.008, maxAllowed);
          return {
            x: chosen.x,
            y: chosen.y,
            r: clamp(chosen.maxR * scaleFactor, minAllowed, maxAllowed),
            room: chosen.maxR,
          };
        }

        function constrainDotToBlob(targetX, targetY, R, r, isTop, padding) {
          const safeOuterR = Math.max(0, R - (r + padding));
          const steps = 180;
          let best = null;

          for (let i = 0; i <= steps; i += 1) {
            const y = -safeOuterR + (2 * safeOuterR * i) / steps;
            const outerX = Math.sqrt(Math.max(0, safeOuterR * safeOuterR - y * y));
            const dividerX = dividerXAtY(y, R);
            const wall = r + padding;
            let left = -outerX;
            let right = outerX;

            if (isTop) {
              right = Math.min(right, dividerX - wall);
            } else {
              left = Math.max(left, dividerX + wall);
            }
            if (right < left) continue;

            const x = clamp(targetX, left, right);
            const distSq = (x - targetX) * (x - targetX) + (y - targetY) * (y - targetY);
            if (!best || distSq < best.distSq) {
              best = { x, y, distSq };
            }
          }

          if (!best) {
            return null;
          }
          return { x: best.x, y: best.y };
        }

        function stabilizeDotCenter(targetDot, key, R, isTop, padding) {
          const memory = dotMemory[key];
          if (!memory) {
            dotMemory[key] = { x: targetDot.x, y: targetDot.y };
            return targetDot;
          }

          const isResizing =
            (key === "top" && drag.active && drag.mode === "topDotResize") ||
            (key === "bottom" && drag.active && drag.mode === "bottomDotResize");
          const follow = isResizing ? 0.72 : 0.26;

          memory.x += (targetDot.x - memory.x) * follow;
          memory.y += (targetDot.y - memory.y) * follow;

          const clamped = constrainDotToBlob(memory.x, memory.y, R, targetDot.r, isTop, padding);
          if (clamped) {
            memory.x = clamped.x;
            memory.y = clamped.y;
          } else {
            memory.x = targetDot.x;
            memory.y = targetDot.y;
          }

          return { x: memory.x, y: memory.y, r: targetDot.r };
        }

        function geometry() {
          const R = getRadius();
          const padding = DOT_PADDING_CSS * getCanvasScale();
          const dividerPoints = buildDivider(R);
          const areaFractions = estimateColorFractions(R, dividerPoints);
          const dotScaleBias = getDotScaleBias(areaFractions);
          const lobeCenters = getLobeCenters(R);
          const topAuto = findDotAuto(R, "top", state.topDotScale * dotScaleBias.top, padding, lobeCenters);
          const bottomAuto = findDotAuto(R, "bottom", state.bottomDotScale * dotScaleBias.bottom, padding, lobeCenters);
          const topPlaced = constrainDotToBlob(topAuto.x, topAuto.y, R, topAuto.r, true, padding);
          const bottomPlaced = constrainDotToBlob(
            bottomAuto.x,
            bottomAuto.y,
            R,
            bottomAuto.r,
            false,
            padding
          );
          const topTarget = topPlaced
            ? { x: topPlaced.x, y: topPlaced.y, r: topAuto.r }
            : { x: topAuto.x, y: topAuto.y, r: topAuto.r };
          const bottomTarget = bottomPlaced
            ? { x: bottomPlaced.x, y: bottomPlaced.y, r: bottomAuto.r }
            : { x: bottomAuto.x, y: bottomAuto.y, r: bottomAuto.r };

          const topDot = stabilizeDotCenter(topTarget, "top", R, true, padding);
          const bottomDot = stabilizeDotCenter(bottomTarget, "bottom", R, false, padding);
          return { R, dividerPoints, topDot, bottomDot, padding };
        }

        function drawCircle(cx, cy, r) {
          if (r <= 0) return;
          ctx.beginPath();
          ctx.arc(cx, cy, r, 0, TAU);
          ctx.fill();
        }

        function isInsideHost(x, y, R, isTop) {
          if (!isInsideCircle(x, y, R)) return false;
          const white = isWhiteAt(x, y, R);
          return isTop ? white : !white;
        }

        function rayBoundaryDistance(cx, cy, dirX, dirY, R, isTop) {
          const cDot = cx * dirX + cy * dirY;
          const cSq = cx * cx + cy * cy;
          const disc = cDot * cDot + (R * R - cSq);
          if (disc <= 0) return 0;
          const outerT = -cDot + Math.sqrt(disc);
          let lo = 0;
          let hi = Math.max(1e-4, outerT + 1);

          for (let i = 0; i < 14; i += 1) {
            const mid = (lo + hi) * 0.5;
            const px = cx + dirX * mid;
            const py = cy + dirY * mid;
            if (isInsideHost(px, py, R, isTop)) {
              lo = mid;
            } else {
              hi = mid;
            }
          }
          return lo;
        }

        function getDotBlobPoints(dot, R, isTop, padding) {
          const samples = 44;
          const avails = new Array(samples);
          let minAvail = Infinity;
          let maxAvail = 0;
          const baseRadius = Math.max(0.35, dot.r);

          for (let i = 0; i < samples; i += 1) {
            const angle = (i / samples) * TAU;
            const dirX = Math.cos(angle);
            const dirY = Math.sin(angle);
            const boundaryDist = rayBoundaryDistance(dot.x, dot.y, dirX, dirY, R, isTop);
            const avail = Math.max(0.35, boundaryDist - padding);
            avails[i] = avail;
            minAvail = Math.min(minAvail, avail);
            maxAvail = Math.max(maxAvail, avail);
          }

          const avgAvail = avails.reduce((sum, value) => sum + value, 0) / samples;
          const hostAnisotropy = clamp(
            (maxAvail - minAvail) / Math.max(1e-6, avgAvail),
            0,
            1
          );
          const squeeze = clamp((baseRadius - minAvail) / Math.max(1e-6, baseRadius), 0, 1);
          const globalDeform = getGlobalDeformAmount();
          const deformGate = clamp((globalDeform - 0.02) / 0.2, 0, 1);
          const shapeBlend = clamp(
            (0.075 + 0.54 * hostAnisotropy + 0.31 * squeeze) * deformGate,
            0,
            0.82
          );

          const minRadius = Math.max(
            0.28,
            baseRadius * (1 - (0.48 * squeeze + 0.18 * hostAnisotropy) * deformGate)
          );
          const expandCap = baseRadius * (1 + 0.055 + 0.12 * shapeBlend);

          let radii = avails.map((avail) => {
            const localFactor = clamp(avail / Math.max(1e-6, avgAvail), 0.78, 1.24);
            const profileMatch =
              baseRadius * (1 + (localFactor - 1) * (shapeBlend * 0.64));
            const wallFollow = baseRadius + (avail - baseRadius) * (0.14 * shapeBlend);
            const radius = baseRadius * 0.24 + profileMatch * 0.54 + wallFollow * 0.22;
            return clamp(radius, minRadius, Math.min(avail, expandCap));
          });

          for (let pass = 0; pass < 4; pass += 1) {
            const smoothed = new Array(samples);
            for (let i = 0; i < samples; i += 1) {
              const prev = radii[(i - 1 + samples) % samples];
              const curr = radii[i];
              const next = radii[(i + 1) % samples];
              smoothed[i] = clamp((prev + curr * 2 + next) * 0.25, minRadius, avails[i]);
            }
            radii = smoothed;
          }

          const points = new Array(samples);
          for (let i = 0; i < samples; i += 1) {
            const angle = (i / samples) * TAU;
            const radius = radii[i];
            points[i] = {
              x: dot.x + Math.cos(angle) * radius,
              y: dot.y + Math.sin(angle) * radius,
            };
          }
          let minRadiusFinal = Infinity;
          let maxRadiusFinal = 0;
          for (let i = 0; i < samples; i += 1) {
            minRadiusFinal = Math.min(minRadiusFinal, radii[i]);
            maxRadiusFinal = Math.max(maxRadiusFinal, radii[i]);
          }
          const anisotropy = clamp(
            (maxRadiusFinal - minRadiusFinal) / Math.max(1e-6, baseRadius),
            0,
            1
          );
          return { points, anisotropy, squeeze, deformGate };
        }

        function drawDeformedDot(dot, R, isTop, padding) {
          if (dot.r <= 0) return;
          if (!isInsideHost(dot.x, dot.y, R, isTop)) {
            drawCircle(dot.x, dot.y, dot.r);
            return;
          }
          const profile = getDotBlobPoints(dot, R, isTop, padding);
          if (
            !profile ||
            profile.points.length < 3 ||
            (profile.deformGate < 0.03 ||
              (profile.squeeze < 0.008 && profile.anisotropy < 0.025) ||
              profile.anisotropy < 0.006)
          ) {
            drawCircle(dot.x, dot.y, dot.r);
            return;
          }

          const points = profile.points;
          const n = points.length;
          const startMid = {
            x: (points[n - 1].x + points[0].x) * 0.5,
            y: (points[n - 1].y + points[0].y) * 0.5,
          };

          ctx.beginPath();
          ctx.moveTo(startMid.x, startMid.y);
          for (let i = 0; i < n; i += 1) {
            const curr = points[i];
            const next = points[(i + 1) % n];
            const mid = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };
            ctx.quadraticCurveTo(curr.x, curr.y, mid.x, mid.y);
          }
          ctx.closePath();
          ctx.fill();
        }

        function traceSmoothDivider(points) {
          if (points.length < 2) return;
          ctx.beginPath();
          ctx.moveTo(points[0].x, points[0].y);
          for (let i = 1; i < points.length; i += 1) {
            const point = points[i];
            ctx.lineTo(point.x, point.y);
          }
        }

        function draw() {
          resizeCanvasToDisplaySize();
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const w = canvas.width;
          const h = canvas.height;
          const cx = w / 2;
          const cy = h / 2;
          const g = geometry();
          const lineWidth = Math.max(2, g.R * 0.02);

          ctx.save();
          ctx.shadowColor = "rgba(0,0,0,0.28)";
          ctx.shadowBlur = Math.max(10, g.R * 0.08);
          ctx.shadowOffsetY = Math.max(6, g.R * 0.03);
          ctx.beginPath();
          ctx.arc(cx, cy, g.R, 0, TAU);
          ctx.fillStyle = "rgba(0,0,0,0)";
          ctx.fill();
          ctx.restore();

          ctx.save();
          ctx.translate(cx, cy);
          ctx.beginPath();
          ctx.arc(0, 0, g.R, 0, TAU);
          ctx.clip();

          ctx.fillStyle = COLORS.white;
          ctx.beginPath();
          ctx.arc(0, 0, g.R, 0, TAU);
          ctx.fill();

          ctx.fillStyle = COLORS.black;
          traceSmoothDivider(g.dividerPoints);
          const arcSteps = 260;
          for (let i = 0; i <= arcSteps; i += 1) {
            const t = i / arcSteps;
            const theta = Math.PI * 0.5 - Math.PI * t;
            ctx.lineTo(g.R * Math.cos(theta), g.R * Math.sin(theta));
          }
          ctx.closePath();
          ctx.fill();

          ctx.fillStyle = COLORS.black;
          drawDeformedDot(g.topDot, g.R, true, g.padding);
          ctx.fillStyle = COLORS.white;
          drawDeformedDot(g.bottomDot, g.R, false, g.padding);

          ctx.restore();

          ctx.beginPath();
          ctx.arc(cx, cy, g.R, 0, TAU);
          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = "rgba(0,0,0,0.75)";
          ctx.stroke();
        }

        function requestDraw() {
          if (requestDraw._raf) return;
          requestDraw._raf = requestAnimationFrame(() => {
            requestDraw._raf = 0;
            draw();
          });
        }

        canvas.addEventListener("pointerdown", (e) => {
          resizeCanvasToDisplaySize();
          const local = getLocalPoint(e);
          const g = geometry();
          if (!isInsideCircle(local.x, local.y, g.R)) return;

          drag.active = true;
          drag.pointerId = e.pointerId;
          drag.start = local;
          drag.startWhitePush = state.whitePush;
          drag.startBlackPush = state.blackPush;
          drag.startWhiteLift = state.whiteLift;
          drag.startBlackLift = state.blackLift;
          drag.startTopScale = state.topDotScale;
          drag.startBottomScale = state.bottomDotScale;
          drag.grabYNorm = clamp(local.y / g.R, -1, 1);
          const influence = getGrabInfluence(drag.grabYNorm);
          drag.topInfluence = influence.top;
          drag.bottomInfluence = influence.bottom;
          drag.activeDotCenter = { x: 0, y: 0 };
          drag.activeDotStartDist = 0;

          const hitPad = DOT_HIT_PAD_CSS * getCanvasScale();
          const resizePad = DOT_RESIZE_INNER_PAD_CSS * getCanvasScale();
          const topDist = Math.hypot(local.x - g.topDot.x, local.y - g.topDot.y);
          const bottomDist = Math.hypot(local.x - g.bottomDot.x, local.y - g.bottomDot.y);
          const topGrabR = g.topDot.r + hitPad;
          const bottomGrabR = g.bottomDot.r + hitPad;
          const nearTopDot = topDist <= topGrabR;
          const nearBottomDot = bottomDist <= bottomGrabR;

          if (nearTopDot || nearBottomDot) {
            let selected = "top";
            if (!nearTopDot) {
              selected = "bottom";
            } else if (nearBottomDot) {
              const topNorm = topDist / Math.max(1e-6, topGrabR);
              const bottomNorm = bottomDist / Math.max(1e-6, bottomGrabR);
              selected = topNorm <= bottomNorm ? "top" : "bottom";
            }

            if (selected === "top") {
              if (topDist <= g.topDot.r + resizePad) {
                drag.mode = "topDotResize";
                drag.activeDotCenter = { x: g.topDot.x, y: g.topDot.y };
                drag.activeDotStartDist = topDist;
              } else {
                drag.mode = isWhiteAt(local.x, local.y, g.R) ? "white" : "black";
              }
            } else if (bottomDist <= g.bottomDot.r + resizePad) {
              drag.mode = "bottomDotResize";
              drag.activeDotCenter = { x: g.bottomDot.x, y: g.bottomDot.y };
              drag.activeDotStartDist = bottomDist;
            } else {
              drag.mode = isWhiteAt(local.x, local.y, g.R) ? "white" : "black";
            }
          } else {
            drag.mode = isWhiteAt(local.x, local.y, g.R) ? "white" : "black";
          }

          canvas.setPointerCapture(e.pointerId);
        });

        canvas.addEventListener("pointermove", (e) => {
          if (!drag.active || e.pointerId !== drag.pointerId) return;
          resizeCanvasToDisplaySize();
          const local = getLocalPoint(e);
          const R = getRadius();
          const dx = local.x - drag.start.x;
          const dy = local.y - drag.start.y;

          if (drag.mode === "white" || drag.mode === "black") {
            const horizontal = dx / (0.78 * R);
            const vertical = dy / (0.84 * R);
            const topGain = 0.2 + 1.3 * drag.topInfluence;
            const bottomGain = 0.2 + 1.3 * drag.bottomInfluence;
            state.whitePush = clamp(drag.startWhitePush + horizontal * topGain, 0, 1);
            state.blackPush = clamp(drag.startBlackPush - horizontal * bottomGain, 0, 1);
            state.whiteLift = clamp(drag.startWhiteLift + vertical * topGain, -1, 1);
            state.blackLift = clamp(drag.startBlackLift + vertical * bottomGain, -1, 1);
          } else if (drag.mode === "topDotResize") {
            const currentDist = Math.hypot(
              local.x - drag.activeDotCenter.x,
              local.y - drag.activeDotCenter.y
            );
            const delta = currentDist - drag.activeDotStartDist;
            state.topDotScale = clamp(drag.startTopScale + delta / (0.74 * R), 0.08, 2.8);
          } else if (drag.mode === "bottomDotResize") {
            const currentDist = Math.hypot(
              local.x - drag.activeDotCenter.x,
              local.y - drag.activeDotCenter.y
            );
            const delta = currentDist - drag.activeDotStartDist;
            state.bottomDotScale = clamp(drag.startBottomScale + delta / (0.74 * R), 0.08, 2.8);
          }

          requestDraw();
        });

        function endDrag(e) {
          if (!drag.active || e.pointerId !== drag.pointerId) return;
          drag.active = false;
          drag.pointerId = null;
          drag.mode = null;
          requestDraw();
        }

        canvas.addEventListener("pointerup", endDrag);
        canvas.addEventListener("pointercancel", endDrag);
        window.addEventListener("resize", requestDraw, { passive: true });

        requestDraw();
      })();
    </script>
  </body>
</html>
